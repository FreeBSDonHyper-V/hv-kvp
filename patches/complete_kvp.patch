Index: contrib/hyperv/tools/hv_kvp_daemon.8
===================================================================
--- contrib/hyperv/tools/hv_kvp_daemon.8	(revision 0)
+++ contrib/hyperv/tools/hv_kvp_daemon.8	(working copy)
@@ -0,0 +1,68 @@
+.\" Copyright (c) 2014 Microsoft Corp.
+.\" All rights reserved.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.Dd September 10, 2013
+.Dt HYPER-V 4
+.Os
+.Sh NAME
+.Nm hv_kvp_daemon
+.Nd Hyper-V Key Value Pair Daemon
+.Sh SYNOPSIS
+The \fBhv_kvp_daemon\fP daemon provides the ability to store, retrieve, modify and delete 
+Key Value pairs for FreeBSD guest partitions running on Hyper-V.
+.Sh DESCRIPTION
+Hyper-V allows administrators to store custom metadata in the form
+of Key Value pairs inside the FreeBSD guest partition. Administrators can
+use Windows Powershell scripts to add, read, modify and delete such
+Key Value pairs.
+
+The \fBhv_kvp_daemon\fP accepts Key Value pair management requests from the
+\fBhv_utils\fP driver and performs the actual metadata management on the file-system.
+
+The same daemon and driver combination is also used to set and get
+IP addresses from a FreeBSD guest. 
+
+The set functionality is particularly
+useful when the FreeBSD guest is assigned a static IP address and is failed
+over from one Hyper-V host to another. After failover, Hyper-V uses the set IP
+functionality to automatically
+update the FreeBSD guest's IP address to its original static value. 
+
+On the other hand, the get IP functionality is used to update the guest IP
+address in the Hyper-V management console window.
+.Sh SEE ALSO
+.Xr hv_vmbus 4 ,
+.Xr hv_utils 4 ,
+.Xr hv_netvsc 4 ,
+.Xr hv_storvsc 4 ,
+.Xr hv_ata_pci_disengage 4
+.Sh HISTORY
+Support for Hyper-V in the form of ports was first released in September 2013.
+The daemon was developed through a joint effort between Citrix Inc., 
+Microsoft Corp. and Network Appliance Inc..
+.Sh AUTHORS
+.An -nosplit
+.Fx
+support for \fBhv_kvp_daemon\fP was first added by
+.An Microsoft BSD Integration Services Team Aq bsdic@microsoft.com .

Property changes on: contrib/hyperv/tools/hv_kvp_daemon.8
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+text/plain
\ No newline at end of property
Added: svn:keywords
## -0,0 +1 ##
+FreeBSD=%H
\ No newline at end of property
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: contrib/hyperv/tools/hv_kvp_daemon.c
===================================================================
--- contrib/hyperv/tools/hv_kvp_daemon.c	(revision 0)
+++ contrib/hyperv/tools/hv_kvp_daemon.c	(working copy)
@@ -0,0 +1,1431 @@
+/*
+ * An implementation of key value pair (KVP) functionality for Linux.
+ *
+ *
+ * Copyright (C) 2010, Novell, Inc.
+ * Author : K. Y. Srinivasan <ksrinivasan@novell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ * NON INFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+/* header */
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/poll.h>
+#include <sys/utsname.h>
+#include <sys/stat.h>
+#include <sys/un.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include <syslog.h>
+#include <fcntl.h>
+#include <dirent.h>
+
+#include <arpa/inet.h>
+#include <ifaddrs.h>
+#include <netdb.h>
+
+#include <netinet/in.h>
+#include <net/if_dl.h>
+#include <net/if_types.h>
+
+#include "../../../sys/dev/hyperv/utilities/hv_kvp.h"
+
+typedef uint8_t		__u8;
+typedef uint16_t	__u16;
+typedef uint32_t	__u32;
+typedef uint64_t	__u64;
+
+/*
+ * ENUM Data
+ *
+ */
+
+/* Global Variables */
+enum key_index {
+	FullyQualifiedDomainName = 0,
+	IntegrationServicesVersion, /*This key is serviced in the kernel*/
+	NetworkAddressIPv4,
+	NetworkAddressIPv6,
+	OSBuildNumber,
+	OSName,
+	OSMajorVersion,
+	OSMinorVersion,
+	OSVersion,
+	ProcessorArchitecture
+};
+
+
+enum {
+	IPADDR = 0,
+	NETMASK,
+	GATEWAY,
+	DNS
+};
+
+
+/* Global buffers for KVP communication */
+
+static char *os_name = "";
+static char *os_major = "";
+static char *os_minor = "";
+static char *processor_arch;
+static char *os_build;
+static char *lic_version = "BSD Pre-Release version";
+static struct utsname uts_buf;
+
+/*
+ * The location of the interface configuration file.
+ */
+
+#define MAX_FILE_NAME		100
+#define ENTRIES_PER_BLOCK	50
+
+struct kvp_record {
+	char	key[HV_KVP_EXCHANGE_MAX_KEY_SIZE];
+	char	value[HV_KVP_EXCHANGE_MAX_VALUE_SIZE];
+};
+
+struct kvp_file_state {
+	int			fd;
+	int			num_blocks;
+	struct kvp_record *	records;
+	int			num_records;
+	char			fname[MAX_FILE_NAME];
+};
+
+static struct kvp_file_state kvp_file_info[HV_KVP_POOL_COUNT];
+
+static void kvp_acquire_lock(int pool)
+{
+	struct flock fl = { 0, 0, 0, F_WRLCK, SEEK_SET, 0 };
+
+	fl.l_pid = getpid();
+
+	if (fcntl(kvp_file_info[pool].fd, F_SETLKW, &fl) == -1) {
+		syslog(LOG_ERR, "Failed to acquire the lock pool: %d", pool);
+		exit(EXIT_FAILURE);
+	}
+}
+
+
+static void kvp_release_lock(int pool)
+{
+	struct flock fl = { 0, 0, 0, F_UNLCK, SEEK_SET, 0 };
+
+	fl.l_pid = getpid();
+
+	if (fcntl(kvp_file_info[pool].fd, F_SETLK, &fl) == -1) {
+		perror("fcntl");
+		syslog(LOG_ERR, "Failed to release the lock pool: %d", pool);
+		exit(EXIT_FAILURE);
+	}
+}
+
+
+static void kvp_update_file(int pool)
+{
+	FILE *filep;
+	size_t bytes_written;
+
+	/*
+	 * We are going to write our in-memory registry out to
+	 * disk; acquire the lock first.
+	 */
+	kvp_acquire_lock(pool);
+
+	filep = fopen(kvp_file_info[pool].fname, "w");
+	if (!filep) {
+		kvp_release_lock(pool);
+		syslog(LOG_ERR, "Failed to open file, pool: %d", pool);
+		exit(EXIT_FAILURE);
+	}
+
+	bytes_written = fwrite(kvp_file_info[pool].records,
+		sizeof(struct kvp_record),
+		kvp_file_info[pool].num_records, filep);
+
+	if (ferror(filep) || fclose(filep)) {
+		kvp_release_lock(pool);
+		syslog(LOG_ERR, "Failed to write file, pool: %d", pool);
+		exit(EXIT_FAILURE);
+	}
+
+	kvp_release_lock(pool);
+}
+
+
+static void kvp_update_mem_state(int pool)
+{
+	FILE *filep;
+	size_t records_read = 0;
+	struct kvp_record *record = kvp_file_info[pool].records;
+	struct kvp_record *readp;
+	int num_blocks = kvp_file_info[pool].num_blocks;
+	int alloc_unit = sizeof(struct kvp_record) * ENTRIES_PER_BLOCK;
+
+	kvp_acquire_lock(pool);
+
+	filep = fopen(kvp_file_info[pool].fname, "r");
+	if (!filep) {
+		kvp_release_lock(pool);
+		syslog(LOG_ERR, "Failed to open file, pool: %d", pool);
+		exit(EXIT_FAILURE);
+	}
+	for ( ; ; )
+	{
+		readp = &record[records_read];
+		records_read += fread(readp, sizeof(struct kvp_record),
+			ENTRIES_PER_BLOCK * num_blocks,
+			filep);
+
+		if (ferror(filep)) {
+			syslog(LOG_ERR, "Failed to read file, pool: %d", pool);
+			exit(EXIT_FAILURE);
+		}
+
+		if (!feof(filep)) {
+			/*
+			 * We have more data to read.
+			 */
+			num_blocks++;
+			record = realloc(record, alloc_unit * num_blocks);
+
+			if (record == NULL) {
+				syslog(LOG_ERR, "malloc failed");
+				exit(EXIT_FAILURE);
+			}
+			continue;
+		}
+		break;
+	}
+
+	kvp_file_info[pool].num_blocks = num_blocks;
+	kvp_file_info[pool].records = record;
+	kvp_file_info[pool].num_records = records_read;
+
+	fclose(filep);
+	kvp_release_lock(pool);
+}
+
+
+static int kvp_file_init(void)
+{
+	int fd;
+	FILE *filep;
+	size_t records_read;
+	char *fname;
+	struct kvp_record *record;
+	struct kvp_record *readp;
+	int num_blocks;
+	int i;
+	int alloc_unit = sizeof(struct kvp_record) * ENTRIES_PER_BLOCK;
+
+	if (access("/usr/local/hyperv/pool", F_OK)) {
+		if (mkdir("/usr/local/hyperv/pool", S_IRUSR | S_IWUSR | S_IROTH)) {
+			syslog(LOG_ERR, " Failed to create /usr/local/hyperv/pool");
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	for (i = 0; i < HV_KVP_POOL_COUNT; i++)
+	{
+		fname = kvp_file_info[i].fname;
+		records_read = 0;
+		num_blocks = 1;
+		sprintf(fname, "/usr/local/hyperv/pool/.kvp_pool_%d", i);
+		fd = open(fname, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IROTH);
+
+		if (fd == -1) {
+			return (1);
+		}
+
+
+		filep = fopen(fname, "r");
+		if (!filep) {
+			return (1);
+		}
+
+		record = malloc(alloc_unit * num_blocks);
+		if (record == NULL) {
+			fclose(filep);
+			return (1);
+		}
+		for ( ; ; )
+		{
+			readp = &record[records_read];
+			records_read += fread(readp, sizeof(struct kvp_record),
+				ENTRIES_PER_BLOCK,
+				filep);
+
+			if (ferror(filep)) {
+				syslog(LOG_ERR, "Failed to read file, pool: %d",
+				    i);
+				exit(EXIT_FAILURE);
+			}
+
+			if (!feof(filep)) {
+				/*
+				 * We have more data to read.
+				 */
+				num_blocks++;
+				record = realloc(record, alloc_unit *
+					num_blocks);
+				if (record == NULL) {
+					fclose(filep);
+					return (1);
+				}
+				continue;
+			}
+			break;
+		}
+		kvp_file_info[i].fd = fd;
+		kvp_file_info[i].num_blocks = num_blocks;
+		kvp_file_info[i].records = record;
+		kvp_file_info[i].num_records = records_read;
+		fclose(filep);
+	}
+
+	return (0);
+}
+
+
+static int kvp_key_delete(int pool, __u8 *key, int key_size)
+{
+	int i;
+	int j, k;
+	int num_records;
+	struct kvp_record *record;
+
+	/*
+	 * First update the in-memory state.
+	 */
+	kvp_update_mem_state(pool);
+
+	num_records = kvp_file_info[pool].num_records;
+	record = kvp_file_info[pool].records;
+
+	for (i = 0; i < num_records; i++)
+	{
+		if (memcmp(key, record[i].key, key_size)) {
+			continue;
+		}
+
+		/*
+		 * Found a match; just move the remaining
+		 * entries up.
+		 */
+		if (i == num_records) {
+			kvp_file_info[pool].num_records--;
+			kvp_update_file(pool);
+			return (0);
+		}
+
+		j = i;
+		k = j + 1;
+		for ( ; k < num_records; k++)
+		{
+			strcpy(record[j].key, record[k].key);
+			strcpy(record[j].value, record[k].value);
+			j++;
+		}
+		kvp_file_info[pool].num_records--;
+		kvp_update_file(pool);
+		return (0);
+	}
+	return (1);
+}
+
+
+static int
+kvp_key_add_or_modify(int pool, __u8 *key, __u32 key_size, __u8 *value,
+    __u32 value_size)
+{
+	int i;
+	int num_records;
+	struct kvp_record *record;
+	int num_blocks;
+
+	if ((key_size > HV_KVP_EXCHANGE_MAX_KEY_SIZE) ||
+	    (value_size > HV_KVP_EXCHANGE_MAX_VALUE_SIZE)) {
+		printf("kvp_key_add_or_modify: returning 1\n");
+		return (1);
+	}
+
+	/*
+	 * First update the in-memory state.
+	 */
+	kvp_update_mem_state(pool);
+
+	num_records = kvp_file_info[pool].num_records;
+	record = kvp_file_info[pool].records;
+	num_blocks = kvp_file_info[pool].num_blocks;
+
+	for (i = 0; i < num_records; i++)
+	{
+		if (memcmp(key, record[i].key, key_size)) {
+			continue;
+		}
+
+		/*
+		 * Found a match; just update the value -
+		 * this is the modify case.
+		 */
+		memcpy(record[i].value, value, value_size);
+		kvp_update_file(pool);
+		return (0);
+	}
+
+	/*
+	 * Need to add a new entry;
+	 */
+	if (num_records == (ENTRIES_PER_BLOCK * num_blocks)) {
+		/* Need to allocate a larger array for reg entries. */
+		record = realloc(record, sizeof(struct kvp_record) *
+			ENTRIES_PER_BLOCK * (num_blocks + 1));
+
+		if (record == NULL) {
+			return (1);
+		}
+		kvp_file_info[pool].num_blocks++;
+	}
+	memcpy(record[i].value, value, value_size);
+	memcpy(record[i].key, key, key_size);
+	kvp_file_info[pool].records = record;
+	kvp_file_info[pool].num_records++;
+	kvp_update_file(pool);
+	return (0);
+}
+
+
+static int kvp_get_value(int pool, __u8 *key, int key_size, __u8 *value,
+    int value_size)
+{
+	int i;
+	int num_records;
+	struct kvp_record *record;
+
+	if ((key_size > HV_KVP_EXCHANGE_MAX_KEY_SIZE) ||
+	    (value_size > HV_KVP_EXCHANGE_MAX_VALUE_SIZE)) {
+		return (1);
+	}
+
+	/*
+	 * First update the in-memory state.
+	 */
+	kvp_update_mem_state(pool);
+
+	num_records = kvp_file_info[pool].num_records;
+	record = kvp_file_info[pool].records;
+
+	for (i = 0; i < num_records; i++)
+	{
+		if (memcmp(key, record[i].key, key_size)) {
+			continue;
+		}
+
+		/*
+		 * Found a match; just copy the value out.
+		 */
+		memcpy(value, record[i].value, value_size);
+		return (0);
+	}
+
+	return (1);
+}
+
+
+static int kvp_pool_enumerate(int pool, int index, __u8 *key, int key_size,
+    __u8 *value, int value_size)
+{
+	struct kvp_record *record;
+
+	/*
+	 * First update our in-memory database.
+	 */
+	kvp_update_mem_state(pool);
+	record = kvp_file_info[pool].records;
+
+	if (index >= kvp_file_info[pool].num_records) {
+		return (1);
+	}
+
+	memcpy(key, record[index].key, key_size);
+	memcpy(value, record[index].value, value_size);
+	return (0);
+}
+
+
+void kvp_get_os_info(void)
+{
+	FILE *file;
+	char *p, buf[512];
+
+	uname(&uts_buf);
+	os_build = uts_buf.release;
+	os_name = uts_buf.sysname;
+	processor_arch = uts_buf.machine;
+
+	/*
+	 * The current windows host (win7) expects the build
+	 * string to be of the form: x.y.z
+	 * Strip additional information we may have.
+	 */
+	p = strchr(os_build, '-');
+	if (p) {
+		*p = '\0';
+	}
+
+	/*
+	 * Parse the /etc/os-release file if present:
+	 * http://www.freedesktop.org/software/systemd/man/os-release.html
+	 */
+	file = fopen("/etc/os-release", "r");
+	if (file != NULL) {
+		while (fgets(buf, sizeof(buf), file))
+		{
+			char *value, *q;
+
+			/* Ignore comments */
+			if (buf[0] == '#') {
+				continue;
+			}
+
+			/* Split into name=value */
+			p = strchr(buf, '=');
+			if (!p) {
+				continue;
+			}
+			*p++ = 0;
+
+			/* Remove quotes and newline; un-escape */
+			value = p;
+			q = p;
+			while (*p)
+			{
+				if (*p == '\\') {
+					++p;
+					if (!*p) {
+						break;
+					}
+					*q++ = *p++;
+				} else if ((*p == '\'') || (*p == '"') ||
+				    (*p == '\n')) {
+					++p;
+				} else {
+					*q++ = *p++;
+				}
+			}
+			*q = 0;
+
+			if (!strcmp(buf, "NAME")) {
+				p = strdup(value);
+				if (!p) {
+					break;
+				}
+				os_name = p;
+			} else if (!strcmp(buf, "VERSION_ID")) {
+				p = strdup(value);
+				if (!p) {
+					break;
+				}
+				os_major = p;
+			}
+		}
+		fclose(file);
+		return;
+	}
+
+	/* Fallback for older RH/SUSE releases */
+	file = fopen("/etc/SuSE-release", "r");
+	if (file != NULL) {
+		goto kvp_osinfo_found;
+	}
+	file = fopen("/etc/redhat-release", "r");
+	if (file != NULL) {
+		goto kvp_osinfo_found;
+	}
+
+	/*
+	 * We don't have information about the os.
+	 */
+	return;
+
+kvp_osinfo_found:
+	/* up to three lines */
+	p = fgets(buf, sizeof(buf), file);
+	if (p) {
+		p = strchr(buf, '\n');
+		if (p) {
+			*p = '\0';
+		}
+		p = strdup(buf);
+		if (!p) {
+			goto done;
+		}
+		os_name = p;
+
+		/* second line */
+		p = fgets(buf, sizeof(buf), file);
+		if (p) {
+			p = strchr(buf, '\n');
+			if (p) {
+				*p = '\0';
+			}
+			p = strdup(buf);
+			if (!p) {
+				goto done;
+			}
+			os_major = p;
+
+			/* third line */
+			p = fgets(buf, sizeof(buf), file);
+			if (p) {
+				p = strchr(buf, '\n');
+				if (p) {
+					*p = '\0';
+				}
+				p = strdup(buf);
+				if (p) {
+					os_minor = p;
+				}
+			}
+		}
+	}
+
+done:
+	fclose(file);
+}
+
+
+/*
+ * Retrieve an interface name corresponding to the specified guid.
+ * If there is a match, the function returns a pointer
+ * to the interface name and if not, a NULL is returned.
+ * If a match is found, the caller is responsible for
+ * freeing the memory.
+ */
+static char *kvp_if_name_to_mac(char *);
+
+static char *get_mac_address(const char *sdlstring)
+{
+	char octet[4];
+	char buf[256] = "\0";
+	int i;
+	char *mac = NULL;
+
+	for (i = 0; i < 6; i++)
+	{
+		if (i != 5) {
+			snprintf(octet, sizeof(octet), "%02x:", (unsigned char)sdlstring[i]);
+		} else{
+			snprintf(octet, sizeof(octet), "%02x", (unsigned char)sdlstring[i]);
+		}
+		strcat(buf, octet);
+	}
+	mac = strdup(buf);
+	return (mac);
+}
+
+
+/*
+ * Retrieve the MAC address given the interface name.
+ */
+static char *kvp_if_name_to_mac(char *if_name)
+{
+	char *mac_addr = NULL;
+	struct ifaddrs *ifaddrs_ptr;
+	struct ifaddrs *head_ifaddrs_ptr;
+	struct sockaddr_dl *sdl;
+	int status;
+
+	status = getifaddrs(&ifaddrs_ptr);
+
+	if (status >= 0) {
+		head_ifaddrs_ptr = ifaddrs_ptr;
+		do
+		{
+			sdl = (struct sockaddr_dl *)ifaddrs_ptr->ifa_addr;
+			if ((sdl->sdl_type == IFT_ETHER) &&
+			    (strcmp(ifaddrs_ptr->ifa_name, if_name) == 0)) {
+				mac_addr = get_mac_address(LLADDR(sdl));
+				break;
+			}
+		} while ((ifaddrs_ptr = ifaddrs_ptr->ifa_next) != NULL);
+		freeifaddrs(head_ifaddrs_ptr);
+	}
+
+	return (mac_addr);
+}
+
+
+/*
+ * Retrieve the interface name given tha MAC address.
+ */
+static char *kvp_mac_to_if_name(char *mac)
+{
+	char *if_name = NULL;
+	struct ifaddrs *ifaddrs_ptr;
+	struct ifaddrs *head_ifaddrs_ptr;
+	struct sockaddr_dl *sdl;
+	int status, i;
+	char *buf_ptr;
+
+	status = getifaddrs(&ifaddrs_ptr);
+
+	if (status >= 0) {
+		head_ifaddrs_ptr = ifaddrs_ptr;
+		do
+		{
+			sdl = (struct sockaddr_dl *)ifaddrs_ptr->ifa_addr;
+			if (sdl->sdl_type == IFT_ETHER) {
+				buf_ptr = get_mac_address(LLADDR(sdl));
+				for (i = 0; i < strlen(buf_ptr); i++)
+				{
+					buf_ptr[i] = toupper(buf_ptr[i]);
+				}
+
+				if (strncmp(buf_ptr, mac, strlen(mac)) == 0) {
+					/* Caller will free the memory */
+					if_name = strdup(ifaddrs_ptr->ifa_name);
+					free(buf_ptr);
+					break;
+				}else if (buf_ptr != NULL) {
+					free(buf_ptr);
+				}
+			}
+		} while ((ifaddrs_ptr = ifaddrs_ptr->ifa_next) != NULL);
+		freeifaddrs(head_ifaddrs_ptr);
+	}
+	return (if_name);
+}
+
+
+static void kvp_process_ipconfig_file(char *cmd,
+    char *config_buf, int len,
+    int element_size, int offset)
+{
+	char buf[256];
+	char *p;
+	char *x;
+	FILE *file;
+
+	/*
+	 * First execute the command.
+	 */
+	file = popen(cmd, "r");
+	if (file == NULL) {
+		return;
+	}
+
+	if (offset == 0) {
+		memset(config_buf, 0, len);
+	}
+	while ((p = fgets(buf, sizeof(buf), file)) != NULL)
+	{
+		if ((len - strlen(config_buf)) < (element_size + 1)) {
+			break;
+		}
+
+		x = strchr(p, '\n');
+		*x = '\0';
+		strcat(config_buf, p);
+		strcat(config_buf, ";");
+	}
+	pclose(file);
+}
+
+
+static void kvp_get_ipconfig_info(char *if_name,
+    struct hv_kvp_ipaddr_value *buffer)
+{
+	char cmd[512];
+	char dhcp_info[128];
+	char *p;
+	FILE *file;
+
+	/*
+	 * Get the address of default gateway (ipv4).
+	 */
+
+	sprintf(cmd, "%s %s", "netstat -rn | grep", if_name);
+	strcat(cmd, " | awk '/default/ {print $2 }'");
+
+	/*
+	 * Execute the command to gather gateway info.
+	 */
+	kvp_process_ipconfig_file(cmd, (char *)buffer->gate_way,
+	    (MAX_GATEWAY_SIZE * 2), INET_ADDRSTRLEN, 0);
+
+	/*
+	 * Get the address of default gateway (ipv6).
+	 */
+	sprintf(cmd, "%s %s", "netstat -rn inet6 | grep", if_name);
+	strcat(cmd, " | awk '/default/ {print $2 }'");
+
+	/*
+	 * Execute the command to gather gateway info (ipv6).
+	 */
+	kvp_process_ipconfig_file(cmd, (char *)buffer->gate_way,
+	    (MAX_GATEWAY_SIZE * 2), INET6_ADDRSTRLEN, 1);
+
+	/*
+	 * Gather the DNS  state.
+	 * Since there is no standard way to get this information
+	 * across various distributions of interest; we just invoke
+	 * an external script that needs to be ported across distros
+	 * of interest.
+	 *
+	 * Following is the expected format of the information from the script:
+	 *
+	 * ipaddr1 (nameserver1)
+	 * ipaddr2 (nameserver2)
+	 * .
+	 * .
+	 */
+	/* Scripts are stored in /usr/local/hyperv/scripts/ directory */
+	sprintf(cmd, "%s", "sh /usr/local/hyperv/scripts/hv_get_dns_info");
+
+	/*
+	 * Execute the command to gather DNS info.
+	 */
+	kvp_process_ipconfig_file(cmd, (char *)buffer->dns_addr,
+	    (MAX_IP_ADDR_SIZE * 2), INET_ADDRSTRLEN, 0);
+
+	/*
+	 * Gather the DHCP state.
+	 * We will gather this state by invoking an external script.
+	 * The parameter to the script is the interface name.
+	 * Here is the expected output:
+	 *
+	 * Enabled: DHCP enabled.
+	 */
+
+
+	sprintf(cmd, "%s %s", "sh /usr/local/hyperv/scripts/hv_get_dhcp_info", if_name);
+
+	file = popen(cmd, "r");
+	if (file == NULL) {
+		return;
+	}
+
+	p = fgets(dhcp_info, sizeof(dhcp_info), file);
+	if (p == NULL) {
+		pclose(file);
+		return;
+	}
+
+	if (!strncmp(p, "Enabled", 7)) {
+		buffer->dhcp_enabled = 1;
+	} else{
+		buffer->dhcp_enabled = 0;
+	}
+
+	pclose(file);
+}
+
+
+static unsigned int hweight32(unsigned int *w)
+{
+	unsigned int res = *w - ((*w >> 1) & 0x55555555);
+
+	res = (res & 0x33333333) + ((res >> 2) & 0x33333333);
+	res = (res + (res >> 4)) & 0x0F0F0F0F;
+	res = res + (res >> 8);
+	return ((res + (res >> 16)) & 0x000000FF);
+}
+
+
+static int kvp_process_ip_address(void *addrp,
+    int family, char *buffer,
+    int length, int *offset)
+{
+	struct sockaddr_in *addr;
+	struct sockaddr_in6 *addr6;
+	int addr_length;
+	char tmp[50];
+	const char *str;
+
+	if (family == AF_INET) {
+		addr = (struct sockaddr_in *)addrp;
+		str = inet_ntop(family, &addr->sin_addr, tmp, 50);
+		addr_length = INET_ADDRSTRLEN;
+	} else {
+		addr6 = (struct sockaddr_in6 *)addrp;
+		str = inet_ntop(family, &addr6->sin6_addr.s6_addr, tmp, 50);
+		addr_length = INET6_ADDRSTRLEN;
+	}
+
+	if ((length - *offset) < addr_length + 1) {
+		return (HV_KVP_E_FAIL);
+	}
+	if (str == NULL) {
+		strcpy(buffer, "inet_ntop failed\n");
+		return (HV_KVP_E_FAIL);
+	}
+	if (*offset == 0) {
+		strcpy(buffer, tmp);
+	} else{
+		strcat(buffer, tmp);
+	}
+	strcat(buffer, ";");
+
+	*offset += strlen(str) + 1;
+	return (0);
+}
+
+
+static int
+kvp_get_ip_info(int family, char *if_name, int op,
+    void *out_buffer, int length)
+{
+	struct ifaddrs *ifap;
+	struct ifaddrs *curp;
+	int offset = 0;
+	int sn_offset = 0;
+	int error = 0;
+	char *buffer;
+	struct hv_kvp_ipaddr_value *ip_buffer;
+	char cidr_mask[5];                       /* /xyz */
+	int weight;
+	int i;
+	unsigned int *w = NULL;
+	char *sn_str;
+	struct sockaddr_in6 *addr6;
+
+	if (op == HV_KVP_OP_ENUMERATE) {
+		buffer = out_buffer;
+	} else {
+		ip_buffer = out_buffer;
+		buffer = (char *)ip_buffer->ip_addr;
+		ip_buffer->addr_family = 0;
+	}
+
+	/*
+	 * On entry into this function, the buffer is capable of holding the
+	 * maximum key value.
+	 */
+
+	if (getifaddrs(&ifap)) {
+		strcpy(buffer, "getifaddrs failed\n");
+		return (HV_KVP_E_FAIL);
+	}
+
+	curp = ifap;
+	while (curp != NULL)
+	{
+		if (curp->ifa_addr == NULL) {
+			curp = curp->ifa_next;
+			continue;
+		}
+
+		if ((if_name != NULL) &&
+		    (strncmp(curp->ifa_name, if_name, strlen(if_name)))) {
+			/*
+			 * We want info about a specific interface;
+			 * just continue.
+			 */
+			curp = curp->ifa_next;
+			continue;
+		}
+
+		/*
+		 * We only support two address families: AF_INET and AF_INET6.
+		 * If a family value of 0 is specified, we collect both
+		 * supported address families; if not we gather info on
+		 * the specified address family.
+		 */
+		if ((family != 0) && (curp->ifa_addr->sa_family != family)) {
+			curp = curp->ifa_next;
+			continue;
+		}
+		if ((curp->ifa_addr->sa_family != AF_INET) &&
+		    (curp->ifa_addr->sa_family != AF_INET6)) {
+			curp = curp->ifa_next;
+			continue;
+		}
+
+		if (op == HV_KVP_OP_GET_IP_INFO) {
+			/*
+			 * Gather info other than the IP address.
+			 * IP address info will be gathered later.
+			 */
+			if (curp->ifa_addr->sa_family == AF_INET) {
+				ip_buffer->addr_family |= ADDR_FAMILY_IPV4;
+
+				/*
+				 * Get subnet info.
+				 */
+				error = kvp_process_ip_address(
+					curp->ifa_netmask,
+					AF_INET,
+					(char *)
+					ip_buffer->sub_net,
+					length,
+					&sn_offset);
+				if (error) {
+					goto gather_ipaddr;
+				}
+			} else {
+				ip_buffer->addr_family |= ADDR_FAMILY_IPV6;
+
+				/*
+				 * Get subnet info in CIDR format.
+				 */
+				weight = 0;
+				sn_str = (char *)ip_buffer->sub_net;
+				addr6 = (struct sockaddr_in6 *)
+				    curp->ifa_netmask;
+				w = (unsigned int *)addr6->sin6_addr.s6_addr;
+
+				for (i = 0; i < 4; i++)
+				{
+					weight += hweight32(&w[i]);
+				}
+
+				sprintf(cidr_mask, "/%d", weight);
+				if ((length - sn_offset) <
+				    (strlen(cidr_mask) + 1)) {
+					goto gather_ipaddr;
+				}
+
+				if (sn_offset == 0) {
+					strcpy(sn_str, cidr_mask);
+				} else{
+					strcat(sn_str, cidr_mask);
+				}
+				strcat((char *)ip_buffer->sub_net, ";");
+				sn_offset += strlen(sn_str) + 1;
+			}
+
+			/*
+			 * Collect other ip related configuration info.
+			 */
+
+			kvp_get_ipconfig_info(if_name, ip_buffer);
+		}
+
+gather_ipaddr:
+		error = kvp_process_ip_address(curp->ifa_addr,
+			curp->ifa_addr->sa_family,
+			buffer,
+			length, &offset);
+		if (error) {
+			goto getaddr_done;
+		}
+
+		curp = curp->ifa_next;
+	}
+
+getaddr_done:
+	freeifaddrs(ifap);
+	return (error);
+}
+
+
+static int kvp_write_file(FILE *f, char *s1, char *s2, char *s3)
+{
+	int ret;
+
+	ret = fprintf(f, "%s%s%s%s\n", s1, s2, "=", s3);
+
+	if (ret < 0) {
+		return (HV_KVP_E_FAIL);
+	}
+
+	return (0);
+}
+
+
+static int kvp_set_ip_info(char *if_name, struct hv_kvp_ipaddr_value *new_val)
+{
+	int error = 0;
+	char if_file[128];
+	FILE *file;
+	char cmd[512];
+	char *mac_addr;
+
+	/*
+	 * FreeBSD - Configuration File
+	 */
+	snprintf(if_file, sizeof(if_file), "%s%s", "/usr/local/hyperv/", "hv_set_ip_data");
+	file = fopen(if_file, "w");
+
+	if (file == NULL) {
+		syslog(LOG_ERR, "FreeBSD Failed to open config file");
+		return (HV_KVP_E_FAIL);
+	}
+
+	/*
+	 * First write out the MAC address.
+	 */
+
+	mac_addr = kvp_if_name_to_mac(if_name);
+	if (mac_addr == NULL) {
+		error = HV_KVP_E_FAIL;
+		goto setval_error;
+	}
+	/* MAC Address */
+	error = kvp_write_file(file, "HWADDR", "", mac_addr);
+	if (error) {
+		goto setval_error;
+	}
+
+	/* Interface Name  */
+	error = kvp_write_file(file, "IF_NAME", "", if_name);
+	if (error) {
+		goto setval_error;
+	}
+
+	/* IP - Address  */
+	error = kvp_write_file(file, "IP_ADDR", "", (char *)new_val->ip_addr);
+	if (error) {
+		goto setval_error;
+	}
+
+	/* Subnet Mask */
+	error = kvp_write_file(file, "SUBNET", "", (char *)new_val->sub_net);
+	if (error) {
+		goto setval_error;
+	}
+
+
+	/* Gateway */
+	error = kvp_write_file(file, "GATEWAY", "", (char *)new_val->gate_way);
+	if (error) {
+		goto setval_error;
+	}
+
+	/* DNS */
+	error = kvp_write_file(file, "DNS", "", (char *)new_val->dns_addr);
+	if (error) {
+		goto setval_error;
+	}
+
+	/* DHCP */
+	if (new_val->dhcp_enabled) {
+		error = kvp_write_file(file, "DHCP", "", "1");
+	} else{
+		error = kvp_write_file(file, "DHCP", "", "0");
+	}
+
+	if (error) {
+		goto setval_error;
+	}
+
+	goto setval_done;
+
+	/*
+	 * We are done!.
+	 */
+
+setval_done:
+	free(mac_addr);
+	fclose(file);
+
+	/*
+	 * Now that we have populated the configuration file,
+	 * invoke the external script to do its magic.
+	 */
+
+	snprintf(cmd, sizeof(cmd), "%s %s", "sh /usr/local/hyperv/scripts/hv_set_ifconfig", if_file);
+	system(cmd);
+	return (0);
+
+setval_error:
+	syslog(LOG_ERR, "Failed to write config file");
+	free(mac_addr);
+	fclose(file);
+	return (error);
+}
+
+
+static int
+kvp_get_domain_name(char *buffer, int length)
+{
+	struct addrinfo hints, *info;
+	int error = 0;
+
+	gethostname(buffer, length);
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_family = AF_INET;    /* Get only ipv4 addrinfo. */
+	hints.ai_socktype = SOCK_STREAM;
+	hints.ai_flags = AI_CANONNAME;
+
+	error = getaddrinfo(buffer, NULL, &hints, &info);
+	if (error != 0) {
+		strcpy(buffer, "getaddrinfo failed\n");
+		return (error);
+	}
+	strcpy(buffer, info->ai_canonname);
+	freeaddrinfo(info);
+	return (error);
+}
+
+
+int main(void)
+{
+	char *key_value, *key_name, *if_name;
+	int op, pool;
+	int hv_kvp_dev_fd, error, len;
+	struct hv_kvp_msg *hv_kvp_dev_buf;      /* communication buffer */
+	struct hv_kvp_ipaddr_value *kvp_ip_val; /* IP address buf */
+	struct hv_kvp_msg *hv_msg;              /* operation buffer */
+
+	/* Allocate memmory of hv_kvp_dev_buf */
+	hv_kvp_dev_buf = malloc(sizeof(*hv_kvp_dev_buf));
+	hv_msg = malloc(sizeof(*hv_msg));
+
+	/* Memory allocation failed*/
+
+	daemon(1, 0);
+	openlog("HV_KVP", 0, LOG_USER);
+	syslog(LOG_INFO, "HV_KVP starting; pid is:%d", getpid());
+
+
+	/* Basics of KVP */
+	kvp_get_os_info();
+
+	if (kvp_file_init()) {
+		syslog(LOG_ERR, "Failed to initialize the pools");
+		exit(EXIT_FAILURE);
+	}
+
+	/* Open the Character Device */
+	hv_kvp_dev_fd = open("/dev/hv_kvp_dev", O_RDWR);
+
+	if (hv_kvp_dev_fd < 0) {
+		syslog(LOG_ERR, "open /dev/hv_kvp_dev failed; error: %d %s", errno, strerror(errno));
+		close(hv_kvp_dev_fd);
+		exit(EXIT_FAILURE);
+	}
+
+	/* First Register the Daemon */
+	hv_kvp_dev_buf->hdr.kvp_hdr.operation = HV_KVP_OP_REGISTER;
+	len = write(hv_kvp_dev_fd, hv_kvp_dev_buf, sizeof(*hv_kvp_dev_buf));
+
+	while (1)
+	{
+		/* Read from character device */
+		len = pread(hv_kvp_dev_fd, hv_kvp_dev_buf, sizeof(*hv_kvp_dev_buf), 0);
+
+		if (len != sizeof(struct hv_kvp_msg)) {
+			syslog(LOG_ERR, "read len is: %d", len);
+			continue;
+		}
+
+		/* Copy hv_kvp_dev_buf to hv_msg */
+		memcpy(hv_msg, hv_kvp_dev_buf, sizeof(*hv_msg));
+
+		/*
+		 * We will use the KVP header information to pass back
+		 * the error from this daemon. So, first copy the state
+		 * and set the error code to success.
+		 */
+
+		op = hv_msg->hdr.kvp_hdr.operation;
+		pool = hv_msg->hdr.kvp_hdr.pool;
+		hv_msg->hdr.error = HV_KVP_S_OK;
+		
+		printf("Operation : %d \n", op);
+		switch (op)
+		{
+		case HV_KVP_OP_GET_IP_INFO:
+
+			kvp_ip_val = &hv_msg->body.kvp_ip_val;
+
+			if_name =
+			    kvp_mac_to_if_name((char *)kvp_ip_val->adapter_id);
+
+			if (if_name == NULL) {
+				/*
+				 * We could not map the mac address to an
+				 * interface name; return error.
+				 */
+				hv_msg->hdr.error = HV_KVP_E_FAIL;
+				break;
+			}
+			error = kvp_get_ip_info(
+				0, if_name, HV_KVP_OP_GET_IP_INFO,
+				kvp_ip_val,
+				(MAX_IP_ADDR_SIZE * 2));
+			if (error) {
+				hv_msg->hdr.error = error;
+			}
+
+			free(if_name);
+			break;
+
+		case HV_KVP_OP_SET_IP_INFO:
+
+			kvp_ip_val = &hv_msg->body.kvp_ip_val;
+			if_name = (char *)kvp_ip_val->adapter_id;
+			
+			if (if_name == NULL) {
+				/*
+				 * We could not map the guid to an
+				 * interface name; return error.
+				 */
+				hv_msg->hdr.error = HV_KVP_GUID_NOTFOUND;
+				break;
+			}
+			
+			error = kvp_set_ip_info(if_name, kvp_ip_val);
+			if (error) {
+				hv_msg->hdr.error = error;
+			}
+			break;
+
+		case HV_KVP_OP_SET:
+
+			if (kvp_key_add_or_modify(pool,
+			    hv_msg->body.kvp_set.data.key,
+			    hv_msg->body.kvp_set.data.key_size,
+			    hv_msg->body.kvp_set.data.msg_value.value,
+			    hv_msg->body.kvp_set.data.value_size)) {
+				hv_msg->hdr.error = HV_KVP_S_CONT;
+			}
+			break;
+
+		case HV_KVP_OP_GET:
+
+			if (kvp_get_value(pool,
+			    hv_msg->body.kvp_set.data.key,
+			    hv_msg->body.kvp_set.data.key_size,
+			    hv_msg->body.kvp_set.data.msg_value.value,
+			    hv_msg->body.kvp_set.data.value_size)) {
+				hv_msg->hdr.error = HV_KVP_S_CONT;
+			}
+			break;
+
+		case HV_KVP_OP_DELETE:
+
+			if (kvp_key_delete(pool,
+			    hv_msg->body.kvp_delete.key,
+			    hv_msg->body.kvp_delete.key_size)) {
+				hv_msg->hdr.error = HV_KVP_S_CONT;
+			}
+			break;
+
+		default:
+			break;
+		}
+
+		if (op != HV_KVP_OP_ENUMERATE) {
+			goto hv_kvp_done;
+		}
+
+		/*
+		 * If the pool is HV_KVP_POOL_AUTO, dynamically generate
+		 * both the key and the value; if not read from the
+		 * appropriate pool.
+		 */
+		if (pool != HV_KVP_POOL_AUTO) {
+			if (kvp_pool_enumerate(pool,
+			    hv_msg->body.kvp_enum_data.index,
+			    hv_msg->body.kvp_enum_data.data.key,
+			    HV_KVP_EXCHANGE_MAX_KEY_SIZE,
+			    hv_msg->body.kvp_enum_data.data.msg_value.value,
+			    HV_KVP_EXCHANGE_MAX_VALUE_SIZE)) {
+				hv_msg->hdr.error = HV_KVP_S_CONT;
+			}
+			goto hv_kvp_done;
+		}
+
+		key_name = (char *)hv_msg->body.kvp_enum_data.data.key;
+		key_value = (char *)hv_msg->body.kvp_enum_data.data.msg_value.value;
+
+		switch (hv_msg->body.kvp_enum_data.index)
+		{
+		case FullyQualifiedDomainName:
+			kvp_get_domain_name(key_value,
+			    HV_KVP_EXCHANGE_MAX_VALUE_SIZE);
+			strcpy(key_name, "FullyQualifiedDomainName");
+			break;
+
+		case IntegrationServicesVersion:
+			strcpy(key_name, "IntegrationServicesVersion");
+			strcpy(key_value, lic_version);
+			break;
+
+		case NetworkAddressIPv4:
+			kvp_get_ip_info(AF_INET, NULL, HV_KVP_OP_ENUMERATE,
+			    key_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE);
+			strcpy(key_name, "NetworkAddressIPv4");
+			break;
+
+		case NetworkAddressIPv6:
+			kvp_get_ip_info(AF_INET6, NULL, HV_KVP_OP_ENUMERATE,
+			    key_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE);
+			strcpy(key_name, "NetworkAddressIPv6");
+			break;
+
+		case OSBuildNumber:
+			strcpy(key_value, os_build);
+			strcpy(key_name, "OSBuildNumber");
+			break;
+
+		case OSName:
+			strcpy(key_value, os_name);
+			strcpy(key_name, "OSName");
+			break;
+
+		case OSMajorVersion:
+			strcpy(key_value, os_major);
+			strcpy(key_name, "OSMajorVersion");
+			break;
+
+		case OSMinorVersion:
+			strcpy(key_value, os_minor);
+			strcpy(key_name, "OSMinorVersion");
+			break;
+
+		case OSVersion:
+			strcpy(key_value, os_build);
+			strcpy(key_name, "OSVersion");
+			break;
+
+		case ProcessorArchitecture:
+			strcpy(key_value, processor_arch);
+			strcpy(key_name, "ProcessorArchitecture");
+			break;
+
+		default:
+			hv_msg->hdr.error = HV_KVP_S_CONT;
+			break;
+		}
+
+		/*
+		 * Send the value back to the kernel. The response is
+		 * already in the receive buffer.
+		 */
+
+		/* copy the hv_msg to hv_kvp_dev_buf to send the data */
+
+hv_kvp_done:
+		len = pwrite(hv_kvp_dev_fd, hv_msg, sizeof(*hv_kvp_dev_buf), 0);
+
+		if (len != sizeof(struct hv_kvp_msg)) {
+			syslog(LOG_ERR, "write len is: %d", len);
+			goto hv_kvp_done;
+		}
+	}
+}

Property changes on: contrib/hyperv/tools/hv_kvp_daemon.c
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+text/plain
\ No newline at end of property
Added: svn:keywords
## -0,0 +1 ##
+FreeBSD=%H
\ No newline at end of property
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: contrib/hyperv/tools/kvp-install
===================================================================
--- contrib/hyperv/tools/kvp-install	(revision 0)
+++ contrib/hyperv/tools/kvp-install	(working copy)
@@ -0,0 +1,41 @@
+#!/bin/sh
+#
+# make install
+# adds hyperv labels in loader.conf 
+#
+
+if [ "$1" = "PRE-INSTALL" ]; then
+echo "===> Pre-install Check"
+# KVP - Directories Check
+
+echo "===> Checking KVP directories" 
+kvp_dir="/usr/local/hyperv/"
+kvp_dir_scripts="/usr/local/hyperv/scripts"
+
+if [ -d $kvp_dir ]; then
+   if [ -d $kvp_dir_scripts ]; then
+      echo " ### KVP Directories present " 
+   else 
+      echo " ### Creating $kvp_dir_scripts directory "
+      mkdir /usr/local/hyperv/scripts
+   fi
+else 
+   echo " xxx KVP directories not found"
+   echo " ### Creating KVP  directories "
+   mkdir /usr/local/hyperv
+   mkdir /usr/local/hyperv/scripts
+fi
+
+else if [ "$1" = "POST-INSTALL" ]; then
+   test="/boot/loader.conf"
+
+# KVP - daemon label
+echo "===> Adding kvp daemon label" 
+sed -i".bak" '/Label for KVP daemon/d' /etc/rc.conf
+sed -i".bak" '/hv_kvp_daemon_enable/d' /etc/rc.conf
+echo  "# Label for KVP daemon -do not modify" >> /etc/rc.conf
+echo  "hv_kvp_daemon_enable=\"YES\"" >> /etc/rc.conf
+
+fi
+fi
+exit 0

Property changes on: contrib/hyperv/tools/kvp-install
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: contrib/hyperv/tools/scripts/hv_get_dhcp_info
===================================================================
--- contrib/hyperv/tools/scripts/hv_get_dhcp_info	(revision 0)
+++ contrib/hyperv/tools/scripts/hv_get_dhcp_info	(working copy)
@@ -0,0 +1,28 @@
+#!/bin/sh
+#THIs example script retrieves the DHCP state of a given interface.
+# In the interest of keeping the KVP daemon code free of distro specific
+# information; the kvp daemon code invokes this external script to gather
+# DHCP setting for the specific interface.
+#
+# Input: Name of the interface
+#
+# Output: The script prints the string "Enabled" to stdout to indicate
+#	that DHCP is enabled on the interface. If DHCP is not enabled,
+#	the script prints the string "Disabled" to stdout.
+#
+# Each Distro is expected to implement this script in a distro specific
+# fashion. For instance on Distros that ship with Network Manager enabled,
+# this script can be based on the Network Manager APIs for retrieving DHCP
+# information.
+
+if_file="/etc/rc.conf"
+
+dhcp=$(grep -- '^ifconfig_hn0=.*DHCP' "$if_file" 2>/dev/null)
+
+if [ "$dhcp" != "" ];
+then
+echo "Enabled"
+else
+echo "Disabled"
+fi
+
Index: contrib/hyperv/tools/scripts/hv_get_dns_info
===================================================================
--- contrib/hyperv/tools/scripts/hv_get_dns_info	(revision 0)
+++ contrib/hyperv/tools/scripts/hv_get_dns_info	(working copy)
@@ -0,0 +1,17 @@
+#!/bin/sh
+#this example script parses /etc/resolv.conf to retrive DNS information.
+# In the interest of keeping the KVP daemon code free of distro specific
+# information; the kvp daemon code invokes this external script to gather
+# DNS information.
+# This script is expected to print the nameserver values to stdout.
+# Each Distro is expected to implement this script in a distro specific
+# fashion. For instance on Distros that ship with Network Manager enabled,
+# this script can be based on the Network Manager APIs for retrieving DNS
+# entries.
+
+#if test -r /etc/resolv.conf
+#then	
+#	awk -- '/^nameserver/ { print $2 }' /etc/resolv.conf
+#fi
+cat /etc/resolv.conf 2>/dev/null | awk '/^nameserver/ { print $2 }'
+
Index: contrib/hyperv/tools/scripts/hv_set_ifconfig
===================================================================
--- contrib/hyperv/tools/scripts/hv_set_ifconfig	(revision 0)
+++ contrib/hyperv/tools/scripts/hv_set_ifconfig	(working copy)
@@ -0,0 +1,83 @@
+#!/bin/sh
+
+# This example script activates an interface based on the specified
+# configuration.
+#
+# In the interest of keeping the KVP daemon code free of distro specific
+# information; the kvp daemon code invokes this external script to configure
+# the interface.
+#
+# The only argument to this script is the configuration file that is to
+# be used to configure the interface.
+#
+# Each Distro is expected to implement this script in a distro specific
+# fashion. For instance on Distros that ship with Network Manager enabled,
+# this script can be based on the Network Manager APIs for configuring the
+# interface.
+#
+# This example script is based on a RHEL environment.
+#
+# Here is the format of the ip configuration file:
+#
+# HWADDR=macaddr
+# IF_NAME=interface name
+# DHCP=yes (This is optional; if yes, DHCP is configured)
+#
+# IPADDR=ipaddr1
+# IPADDR_1=ipaddr2
+# IPADDR_x=ipaddry (where y = x + 1)
+#
+# NETMASK=netmask1
+# NETMASK_x=netmasky (where y = x + 1)
+#
+# GATEWAY=ipaddr1
+# GATEWAY_x=ipaddry (where y = x + 1)
+#
+# DNSx=ipaddrx (where first DNS address is tagged as DNS1 etc)
+#
+# IPV6 addresses will be tagged as IPV6ADDR, IPV6 gateway will be
+# tagged as IPV6_DEFAULTGW and IPV6 NETMASK will be tagged as
+# IPV6NETMASK.
+#
+# The host can specify multiple ipv4 and ipv6 addresses to be
+# configured for the interface. Furthermore, the configuration
+# needs to be persistent. A subsequent GET call on the interface
+# is expected to return the configuration that is set via the SET
+# call.
+#
+
+. $1
+
+sed -i".bak" '/ifconfig_hn0="SYNCDHCP"/d' /etc/rc.conf
+sed -i".bak" '/ifconfig_hn0="DHCP"/d' /etc/rc.conf
+
+# MAC Address
+ifconfig $IF_NAME ether $HWADDR 
+
+# IP and Subnet Mask
+ifconfig $IF_NAME inet $IP_ADDR netmask $SUBNET 
+
+# DNS
+sed -i".bak" '/nameserver/d' /etc/resolv.conf
+echo "nameserver" $DNS >> /etc/resolv.conf 
+
+#Gateway
+# Need to implment if Gateway is not present 
+route flush
+route add default $GATEWAY
+#route change default $GATEWAY
+
+#/etc/rc.d/netif restart 
+#/etc/rc.d/routing restart
+
+
+# DHCP
+if [ $DHCP -eq 1 ]
+then
+	echo ifconfig_hn0=\"DHCP\" >> /etc/rc.conf
+	echo Enabled 
+else
+	echo Disabled DHCP >> /var/log/messages
+	echo Disabled
+fi
+echo "Set IP-Injection Success"
Index: etc/rc.d/Makefile
===================================================================
--- etc/rc.d/Makefile	(revision 267674)
+++ etc/rc.d/Makefile	(working copy)
@@ -54,6 +54,7 @@
 	hostid \
 	hostid_save \
 	hostname \
+	hv_kvpd \
 	inetd \
 	initrandom \
 	ip6addrctl \
Index: etc/rc.d/hv_kvpd
===================================================================
--- etc/rc.d/hv_kvpd	(revision 0)
+++ etc/rc.d/hv_kvpd	(working copy)
@@ -0,0 +1,16 @@
+#!/bin/sh
+#
+# $FreeBSD: src/etc/rc.d/hv_kvpd $
+#
+
+# PROVIDE: hv_kvpd
+
+. /etc/rc.subr
+
+name="hv_kvp_daemon"
+rcvar=`hv_kvp_daemon`
+command="/usr/sbin/${name}"
+required_dirs="/usr/local/hyperv"
+
+load_rc_config $name
+run_rc_command "$1"
Index: sys/conf/files.amd64
===================================================================
--- sys/conf/files.amd64	(revision 267674)
+++ sys/conf/files.amd64	(working copy)
@@ -224,6 +224,7 @@
 dev/hyperv/netvsc/hv_rndis_filter.c			optional	hyperv
 dev/hyperv/stordisengage/hv_ata_pci_disengage.c		optional	hyperv
 dev/hyperv/storvsc/hv_storvsc_drv_freebsd.c		optional	hyperv
+dev/hyperv/utilities/hv_kvp.c				optional	hyperv
 dev/hyperv/utilities/hv_util.c				optional	hyperv
 dev/hyperv/vmbus/hv_channel.c				optional	hyperv
 dev/hyperv/vmbus/hv_channel_mgmt.c			optional	hyperv
Index: sys/conf/files.i386
===================================================================
--- sys/conf/files.i386	(revision 267674)
+++ sys/conf/files.i386	(working copy)
@@ -215,6 +215,7 @@
 dev/hyperv/netvsc/hv_rndis_filter.c			optional	hyperv
 dev/hyperv/stordisengage/hv_ata_pci_disengage.c		optional	hyperv
 dev/hyperv/storvsc/hv_storvsc_drv_freebsd.c		optional	hyperv
+dev/hyperv/utilities/hv_kvp.c				optional	hyperv
 dev/hyperv/utilities/hv_util.c				optional	hyperv
 dev/hyperv/vmbus/hv_channel.c				optional	hyperv
 dev/hyperv/vmbus/hv_channel_mgmt.c			optional	hyperv
Index: sys/dev/hyperv/include/hyperv.h
===================================================================
--- sys/dev/hyperv/include/hyperv.h	(revision 267674)
+++ sys/dev/hyperv/include/hyperv.h	(working copy)
@@ -795,5 +795,34 @@
 	return (ret);
 }
 
+
+/**
+ * KVP related structures
+ * 
+ */
+typedef struct hv_vmbus_service {
+        hv_guid       guid;             /* Hyper-V GUID */
+        char          *name;            /* name of service */
+        boolean_t     enabled;          /* service enabled */
+        hv_work_queue *work_queue;      /* background work queue */
+
+        /*
+         * function to initialize service
+         */
+        int (*init)(struct hv_vmbus_service *);
+
+        /*
+         * function to process Hyper-V messages
+         */
+        void (*callback)(void *);
+} hv_vmbus_service;
+
+extern uint8_t* receive_buffer[];
+extern hv_vmbus_service service_table[];
+
+void hv_kvp_callback(void *context);
+int hv_kvp_init(hv_vmbus_service *serv);
+void hv_kvp_deinit(void);
+
 #endif  /* __HYPERV_H__ */
 
Index: sys/dev/hyperv/utilities/hv_kvp.c
===================================================================
--- sys/dev/hyperv/utilities/hv_kvp.c	(revision 0)
+++ sys/dev/hyperv/utilities/hv_kvp.c	(working copy)
@@ -0,0 +1,975 @@
+/*-
+ * Copyright (c) 2014 Microsoft Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ *	Author:	Sainath Varanasi.
+ *	Date:	4/2012
+ *	Email:	bsdic@microsoft.com
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/kernel.h>
+#include <sys/conf.h>
+#include <sys/uio.h>
+#include <sys/bus.h>
+#include <sys/malloc.h>
+#include <sys/module.h>
+#include <sys/reboot.h>
+#include <sys/lock.h>
+#include <sys/taskqueue.h>
+#include <sys/sysctl.h>
+#include <sys/proc.h>
+#include <sys/kthread.h>
+#include <sys/syscallsubr.h>
+#include <sys/sysproto.h>
+#include <sys/un.h>
+#include <sys/endian.h>
+#include <sys/_null.h>
+#include <sys/signal.h>
+#include <sys/syslog.h>
+#include <sys/mutex.h>
+#include <net/if_arp.h>
+
+#include <dev/hyperv/include/hyperv.h>
+#include <dev/hyperv/netvsc/hv_net_vsc.h>
+
+#include "unicode.h"
+#include "hv_kvp.h"
+
+/* hv_kvp defines */
+#define BUFFERSIZE	sizeof(struct hv_kvp_msg)
+#define KVP_SUCCESS	0
+#define KVP_ERROR	1
+#define kvp_hdr		hdr.kvp_hdr
+
+/* hv_kvp debug control */
+static int hv_kvp_log = 0;
+SYSCTL_INT(_dev, OID_AUTO, hv_kvp_log, CTLFLAG_RW, &hv_kvp_log, 0,
+	"hv_kvp log");
+
+#define	hv_kvp_log_error(...)	do {				\
+	if (hv_kvp_log > 0)				\
+		log(LOG_ERR, "hv_kvp: " __VA_ARGS__);	\
+} while (0)
+
+#define	hv_kvp_log_info(...) do {				\
+	if (hv_kvp_log > 1)				\
+		log(LOG_INFO, "hv_kvp: " __VA_ARGS__);		\
+} while (0)
+
+/* character device prototypes */
+static d_open_t		hv_kvp_dev_open;
+static d_close_t	hv_kvp_dev_close;
+static d_read_t		hv_kvp_dev_daemon_read;
+static d_write_t	hv_kvp_dev_daemon_write;
+
+/* hv_kvp prototypes */
+static int	hv_kvp_req_in_progress(void);
+static void	hv_kvp_transaction_init(uint32_t, hv_vmbus_channel *, uint64_t, uint8_t *);
+static void	hv_kvp_send_msg_to_daemon(void);
+static void	hv_kvp_process_request(void *context);
+
+/* hv_kvp character device structure */
+static struct cdevsw hv_kvp_cdevsw =
+{
+	.d_version	= D_VERSION,
+	.d_open		= hv_kvp_dev_open,
+	.d_close	= hv_kvp_dev_close,
+	.d_read		= hv_kvp_dev_daemon_read,
+	.d_write	= hv_kvp_dev_daemon_write,
+	.d_name		= "hv_kvp_dev",
+};
+static struct cdev *hv_kvp_dev;
+static struct hv_kvp_msg *hv_kvp_dev_buf;
+struct proc *daemon_task;
+
+/*
+ * Global state to track and synchronize multiple
+ * KVP transaction requests from the host.
+ */
+static struct {
+
+	/* Pre-allocated work item for queue */
+	hv_work_item		work_item;	
+
+	/* Unless specified the pending mutex should be 
+	 * used to alter the values of the following paramters:
+	 * 1. req_in_progress
+	 * 2. req_timed_out
+	 * 3. pending_reqs.
+	 */
+	struct mtx		pending_mutex;	  
+	
+	/* To track if transaction is active or not */
+	boolean_t		req_in_progress;    
+	/* Tracks if daemon did not reply back in time */
+	boolean_t		req_timed_out;	  
+	/* Tracks if daemon is serving a request currently */
+	boolean_t		daemon_busy;
+	/* Count of KVP requests from Hyper-V. */
+	uint64_t		pending_reqs;       
+	
+	
+	/* Length of host message */
+	uint32_t		host_msg_len;	    
+
+	/* Pointer to channel */
+	hv_vmbus_channel	*channelp;	    
+
+	/* Host message id */
+	uint64_t		host_msg_id;	   
+	
+	/* Current kvp message from the host */
+	struct hv_kvp_msg	*host_kvp_msg;      
+	
+	 /* Current kvp message for daemon */
+	struct hv_kvp_msg	daemon_kvp_msg;    
+	
+	/* Rcv buffer for communicating with the host*/
+	uint8_t			*rcv_buf;	    
+	
+	/* Device semaphore to control communication */
+	struct sema		dev_sema;	   
+	
+	/* Indicates if daemon registered with driver */
+	boolean_t		register_done;      
+	
+	/* Character device status */
+	boolean_t		dev_accessed;	    
+} kvp_globals;
+
+/* global vars */
+MALLOC_DECLARE(M_HV_KVP_DEV_BUF);
+MALLOC_DEFINE(M_HV_KVP_DEV_BUF, "hv_kvp_dev buffer", "buffer for hv_kvp_dev module");
+
+/*
+ * hv_kvp low level functions
+ */
+
+/*
+ * Check if kvp transaction is in progres
+ */
+static int
+hv_kvp_req_in_progress(void)
+{
+
+	return (kvp_globals.req_in_progress);
+}
+
+
+/*
+ * This routine is called whenever a message is received from the host
+ */
+static void
+hv_kvp_transaction_init(uint32_t rcv_len, hv_vmbus_channel *rcv_channel,
+			uint64_t request_id, uint8_t *rcv_buf)
+{
+	
+	/* Store all the relevant message details in the global structure */
+	/* Do not need to use mutex for req_in_progress here */
+	kvp_globals.req_in_progress = true;
+	kvp_globals.host_msg_len = rcv_len;
+	kvp_globals.channelp = rcv_channel;
+	kvp_globals.host_msg_id = request_id;
+	kvp_globals.rcv_buf = rcv_buf;
+	kvp_globals.host_kvp_msg = (struct hv_kvp_msg *)&rcv_buf[
+		sizeof(struct hv_vmbus_pipe_hdr) +
+		sizeof(struct hv_vmbus_icmsg_hdr)];
+}
+
+
+/*
+ * hv_kvp - version neogtiation function
+ */
+static void
+hv_kvp_negotiate_version(struct hv_vmbus_icmsg_hdr *icmsghdrp,
+			 struct hv_vmbus_icmsg_negotiate *negop,
+			 uint8_t *buf)
+{
+	int icframe_vercnt;
+	int icmsg_vercnt;
+
+	icmsghdrp->icmsgsize = 0x10;
+
+	negop = (struct hv_vmbus_icmsg_negotiate *)&buf[
+		sizeof(struct hv_vmbus_pipe_hdr) +
+		sizeof(struct hv_vmbus_icmsg_hdr)];
+	icframe_vercnt = negop->icframe_vercnt;
+	icmsg_vercnt = negop->icmsg_vercnt;
+
+	/*
+	 * Select the framework version number we will support
+	 */
+	if ((icframe_vercnt >= 2) && (negop->icversion_data[1].major == 3)) {
+		icframe_vercnt = 3;
+		if (icmsg_vercnt >= 2)
+			icmsg_vercnt = 4;
+		else
+			icmsg_vercnt = 3;
+	} else {
+		icframe_vercnt = 1;
+		icmsg_vercnt = 1;
+	}
+
+	negop->icframe_vercnt = 1;
+	negop->icmsg_vercnt = 1;
+	negop->icversion_data[0].major = icframe_vercnt;
+	negop->icversion_data[0].minor = 0;
+	negop->icversion_data[1].major = icmsg_vercnt;
+	negop->icversion_data[1].minor = 0;
+}
+
+
+/*
+ * Convert ip related info in umsg from utf8 to utf16 and store in hmsg
+ */
+static int
+hv_kvp_convert_utf8_ipinfo_to_utf16(struct hv_kvp_msg *umsg, 
+				    struct hv_kvp_ip_msg *host_ip_msg)
+{
+	int err_ip, err_subnet, err_gway, err_dns, err_adap;
+	int UNUSED_FLAG = 1;
+ 		
+	utf8_to_utf16((uint16_t *)host_ip_msg->kvp_ip_val.ip_addr,
+	    MAX_IP_ADDR_SIZE,
+	    (char *)umsg->body.kvp_ip_val.ip_addr,
+	    strlen((char *)umsg->body.kvp_ip_val.ip_addr),
+	    UNUSED_FLAG,
+	    &err_ip);
+	utf8_to_utf16((uint16_t *)host_ip_msg->kvp_ip_val.sub_net,
+	    MAX_IP_ADDR_SIZE,
+	    (char *)umsg->body.kvp_ip_val.sub_net,
+	    strlen((char *)umsg->body.kvp_ip_val.sub_net),
+	    UNUSED_FLAG,
+	    &err_subnet);
+	utf8_to_utf16((uint16_t *)host_ip_msg->kvp_ip_val.gate_way,
+	    MAX_GATEWAY_SIZE,
+	    (char *)umsg->body.kvp_ip_val.gate_way,
+	    strlen((char *)umsg->body.kvp_ip_val.gate_way),
+	    UNUSED_FLAG,
+	    &err_gway);
+	utf8_to_utf16((uint16_t *)host_ip_msg->kvp_ip_val.dns_addr,
+	    MAX_IP_ADDR_SIZE,
+	    (char *)umsg->body.kvp_ip_val.dns_addr,
+	    strlen((char *)umsg->body.kvp_ip_val.dns_addr),
+	    UNUSED_FLAG,
+	    &err_dns);
+	utf8_to_utf16((uint16_t *)host_ip_msg->kvp_ip_val.adapter_id,
+	    MAX_IP_ADDR_SIZE,
+	    (char *)umsg->body.kvp_ip_val.adapter_id,
+	    strlen((char *)umsg->body.kvp_ip_val.adapter_id),
+	    UNUSED_FLAG,
+	    &err_adap);
+	
+	host_ip_msg->kvp_ip_val.dhcp_enabled = umsg->body.kvp_ip_val.dhcp_enabled;
+	host_ip_msg->kvp_ip_val.addr_family = umsg->body.kvp_ip_val.addr_family;
+
+	return (err_ip | err_subnet | err_gway | err_dns | err_adap);
+}
+
+
+/*
+ * Convert ip related info in hmsg from utf16 to utf8 and store in umsg
+ */
+static int
+hv_kvp_convert_utf16_ipinfo_to_utf8(struct hv_kvp_ip_msg *host_ip_msg,
+				    struct hv_kvp_msg *umsg)
+{
+	int err_ip, err_subnet, err_gway, err_dns, err_adap;
+	int UNUSED_FLAG = 1;
+	int guid_index;
+	struct hv_device *hv_dev;       /* GUID Data Structure */
+	hn_softc_t *sc;                 /* hn softc structure  */
+	char if_name[4];
+	unsigned char guid_instance[40];
+	char *guid_data = NULL;
+	char buf[39];
+
+	struct guid_extract {
+		char	a1[2];
+		char	a2[2];
+		char	a3[2];
+		char	a4[2];
+		char	b1[2];
+		char	b2[2];
+		char	c1[2];
+		char	c2[2];
+		char	d[4];
+		char	e[12];
+	};
+
+	struct guid_extract *id;
+	device_t *devs;
+	int devcnt;
+
+	/* IP Address */
+	utf16_to_utf8((char *)umsg->body.kvp_ip_val.ip_addr,
+	    MAX_IP_ADDR_SIZE,
+	    (uint16_t *)host_ip_msg->kvp_ip_val.ip_addr,
+	    MAX_IP_ADDR_SIZE,
+	    UNUSED_FLAG,
+	    &err_ip);
+
+	/* Adapter ID : GUID */
+	utf16_to_utf8((char *)umsg->body.kvp_ip_val.adapter_id,
+	    MAX_ADAPTER_ID_SIZE,
+	    (uint16_t *)host_ip_msg->kvp_ip_val.adapter_id,
+	    MAX_ADAPTER_ID_SIZE,
+	    UNUSED_FLAG,
+	    &err_adap);
+
+	if (devclass_get_devices(devclass_find("hn"), &devs, &devcnt) == 0) {
+		for (devcnt = devcnt - 1; devcnt >= 0; devcnt--) {
+			sc = device_get_softc(devs[devcnt]);
+
+			/* Trying to find GUID of Network Device */
+			hv_dev = sc->hn_dev_obj;
+
+			for (guid_index = 0; guid_index < 16; guid_index++) {
+				sprintf(&guid_instance[guid_index * 2], "%02x",
+				    hv_dev->device_id.data[guid_index]);
+			}
+
+			guid_data = (char *)guid_instance;
+			id = (struct guid_extract *)guid_data;
+			snprintf(buf, sizeof(buf), "{%.2s%.2s%.2s%.2s-%.2s%.2s-%.2s%.2s-%.4s-%s}",
+			    id->a4, id->a3, id->a2, id->a1,
+			    id->b2, id->b1, id->c2, id->c1, id->d, id->e);
+			guid_data = NULL;
+			sprintf(if_name, "%s%d", "hn", device_get_unit(devs[devcnt]));
+
+			if (strncmp(buf, (char *)umsg->body.kvp_ip_val.adapter_id, 39) == 0) {
+				strcpy((char *)umsg->body.kvp_ip_val.adapter_id, if_name);
+				break;
+			}
+		}
+		free(devs, M_TEMP);
+	}
+
+	/* Address Family , DHCP , SUBNET, Gateway, DNS */
+	umsg->kvp_hdr.operation = host_ip_msg->operation;
+	umsg->body.kvp_ip_val.addr_family = host_ip_msg->kvp_ip_val.addr_family;
+	umsg->body.kvp_ip_val.dhcp_enabled = host_ip_msg->kvp_ip_val.dhcp_enabled;
+	utf16_to_utf8((char *)umsg->body.kvp_ip_val.sub_net, MAX_IP_ADDR_SIZE,
+	    (uint16_t *)host_ip_msg->kvp_ip_val.sub_net,
+	    MAX_IP_ADDR_SIZE,
+	    UNUSED_FLAG,
+	    &err_subnet);
+	
+	utf16_to_utf8((char *)umsg->body.kvp_ip_val.gate_way, MAX_GATEWAY_SIZE,
+	    (uint16_t *)host_ip_msg->kvp_ip_val.gate_way,
+	    MAX_GATEWAY_SIZE,
+	    UNUSED_FLAG,
+	    &err_gway);
+
+	utf16_to_utf8((char *)umsg->body.kvp_ip_val.dns_addr, MAX_IP_ADDR_SIZE,
+	    (uint16_t *)host_ip_msg->kvp_ip_val.dns_addr,
+	    MAX_IP_ADDR_SIZE,
+	    UNUSED_FLAG,
+	    &err_dns);
+
+	return (err_ip | err_subnet | err_gway | err_dns | err_adap);
+}
+
+
+/*
+ * Prepare a user kvp msg based on host kvp msg (utf16 to utf8)
+ * Ensure utf16_utf8 takes care of the additional string terminating char!!
+ */
+static void
+hv_kvp_convert_hostmsg_to_usermsg(void)
+{
+	int utf_err = 0;
+	uint32_t value_type;
+	struct hv_kvp_ip_msg *host_ip_msg = (struct hv_kvp_ip_msg *)
+		kvp_globals.host_kvp_msg;
+
+	struct hv_kvp_msg *hmsg = kvp_globals.host_kvp_msg;
+	struct hv_kvp_msg *umsg = &kvp_globals.daemon_kvp_msg;
+
+	memset(umsg, 0, sizeof(struct hv_kvp_msg));
+
+	umsg->kvp_hdr.operation = hmsg->kvp_hdr.operation;
+	umsg->kvp_hdr.pool = hmsg->kvp_hdr.pool;
+
+	switch (umsg->kvp_hdr.operation) {
+	case HV_KVP_OP_SET_IP_INFO:
+		hv_kvp_convert_utf16_ipinfo_to_utf8(host_ip_msg, umsg);
+		break;
+
+	case HV_KVP_OP_GET_IP_INFO:
+		utf16_to_utf8((char *)umsg->body.kvp_ip_val.adapter_id,
+		    MAX_ADAPTER_ID_SIZE,
+		    (uint16_t *)host_ip_msg->kvp_ip_val.adapter_id,
+		    MAX_ADAPTER_ID_SIZE, 1, &utf_err);
+
+		umsg->body.kvp_ip_val.addr_family =
+		    host_ip_msg->kvp_ip_val.addr_family;
+		break;
+
+	case HV_KVP_OP_SET:
+		value_type = hmsg->body.kvp_set.data.value_type;
+
+		switch (value_type) {
+		case HV_REG_SZ:
+			umsg->body.kvp_set.data.value_size =
+			    utf16_to_utf8(
+				(char *)umsg->body.kvp_set.data.msg_value.value,
+				HV_KVP_EXCHANGE_MAX_VALUE_SIZE - 1,
+				(uint16_t *)hmsg->body.kvp_set.data.msg_value.value,
+				hmsg->body.kvp_set.data.value_size,
+				1, &utf_err);
+			/* utf8 encoding */
+			umsg->body.kvp_set.data.value_size =
+			    umsg->body.kvp_set.data.value_size / 2;
+			break;
+
+		case HV_REG_U32:
+			umsg->body.kvp_set.data.value_size =
+			    sprintf(umsg->body.kvp_set.data.msg_value.value, "%d",
+				hmsg->body.kvp_set.data.msg_value.value_u32) + 1;
+			break;
+
+		case HV_REG_U64:
+			umsg->body.kvp_set.data.value_size =
+			    sprintf(umsg->body.kvp_set.data.msg_value.value, "%llu",
+				(unsigned long long)
+				hmsg->body.kvp_set.data.msg_value.value_u64) + 1;
+			break;
+		}
+
+		umsg->body.kvp_set.data.key_size =
+		    utf16_to_utf8(
+			umsg->body.kvp_set.data.key,
+			HV_KVP_EXCHANGE_MAX_KEY_SIZE - 1,
+			(uint16_t *)hmsg->body.kvp_set.data.key,
+			hmsg->body.kvp_set.data.key_size,
+			1, &utf_err);
+
+		/* utf8 encoding */
+		umsg->body.kvp_set.data.key_size =
+		    umsg->body.kvp_set.data.key_size / 2;
+		break;
+
+	case HV_KVP_OP_GET:
+		umsg->body.kvp_get.data.key_size =
+		    utf16_to_utf8(umsg->body.kvp_get.data.key,
+			HV_KVP_EXCHANGE_MAX_KEY_SIZE - 1,
+			(uint16_t *)hmsg->body.kvp_get.data.key,
+			hmsg->body.kvp_get.data.key_size,
+			1, &utf_err);
+		/* utf8 encoding */
+		umsg->body.kvp_get.data.key_size =
+		    umsg->body.kvp_get.data.key_size / 2;
+		break;
+
+	case HV_KVP_OP_DELETE:
+		umsg->body.kvp_delete.key_size =
+		    utf16_to_utf8(umsg->body.kvp_delete.key,
+			HV_KVP_EXCHANGE_MAX_KEY_SIZE - 1,
+			(uint16_t *)hmsg->body.kvp_delete.key,
+			hmsg->body.kvp_delete.key_size,
+			1, &utf_err);
+		/* utf8 encoding */
+		umsg->body.kvp_delete.key_size =
+		    umsg->body.kvp_delete.key_size / 2;
+		break;
+
+	case HV_KVP_OP_ENUMERATE:
+		umsg->body.kvp_enum_data.index =
+		    hmsg->body.kvp_enum_data.index;
+		break;
+
+	default:
+		hv_kvp_log_info("%s: daemon_kvp_msg: Invalid operation : %d\n",
+		    __func__, umsg->kvp_hdr.operation);
+	}
+}
+
+
+/*
+ * Prepare a host kvp msg based on user kvp msg (utf8 to utf16)
+ */
+static int
+hv_kvp_convert_usermsg_to_hostmsg(void)
+{
+	int hkey_len = 0, hvalue_len = 0, utf_err = 0;
+	struct hv_kvp_exchg_msg_value *host_exchg_data;
+	char *key_name, *value;
+
+	struct hv_kvp_msg *umsg = &kvp_globals.daemon_kvp_msg;
+	struct hv_kvp_msg *hmsg = kvp_globals.host_kvp_msg;
+	struct hv_kvp_ip_msg *host_ip_msg = (struct hv_kvp_ip_msg *)hmsg;
+
+	switch (hmsg->kvp_hdr.operation) {
+	case HV_KVP_OP_GET_IP_INFO:
+		return (hv_kvp_convert_utf8_ipinfo_to_utf16(umsg, host_ip_msg));
+
+	case HV_KVP_OP_SET_IP_INFO:
+	case HV_KVP_OP_SET:
+	case HV_KVP_OP_DELETE:
+		return (KVP_SUCCESS);
+
+	case HV_KVP_OP_ENUMERATE:
+		host_exchg_data = &hmsg->body.kvp_enum_data.data;
+		key_name = umsg->body.kvp_enum_data.data.key;
+		hkey_len = utf8_to_utf16((uint16_t *)host_exchg_data->key,
+				((HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2) - 2),
+				key_name, strlen(key_name),
+				1, &utf_err);
+		/* utf16 encoding */
+		host_exchg_data->key_size = 2 * (hkey_len + 1);
+		value = umsg->body.kvp_enum_data.data.msg_value.value;
+		hvalue_len = utf8_to_utf16(
+				(uint16_t *)host_exchg_data->msg_value.value,
+				((HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2) - 2),
+				value, strlen(value),
+				1, &utf_err);
+		host_exchg_data->value_size = 2 * (hvalue_len + 1);
+		host_exchg_data->value_type = HV_REG_SZ;
+
+		if ((hkey_len < 0) || (hvalue_len < 0))
+			return (HV_KVP_E_FAIL);
+			
+		return (KVP_SUCCESS);
+
+	case HV_KVP_OP_GET:
+		host_exchg_data = &hmsg->body.kvp_get.data;
+		value = umsg->body.kvp_get.data.msg_value.value;
+		hvalue_len = utf8_to_utf16(
+				(uint16_t *)host_exchg_data->msg_value.value,
+				((HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2) - 2),
+				value, strlen(value),
+				1, &utf_err);
+		/* Convert value size to uft16 */
+		host_exchg_data->value_size = 2 * (hvalue_len + 1);
+		/* Use values by string */
+		host_exchg_data->value_type = HV_REG_SZ;
+
+		if ((hkey_len < 0) || (hvalue_len < 0)) 
+			return (HV_KVP_E_FAIL);
+			
+		return (KVP_SUCCESS);
+
+	default:
+		return (HV_KVP_E_FAIL);
+	}
+}
+
+
+/*
+ * Send the response back to the host.
+ */
+static void
+hv_kvp_respond_host(int error)
+{
+	struct hv_vmbus_icmsg_hdr *hv_icmsg_hdrp;
+
+	hv_icmsg_hdrp = (struct hv_vmbus_icmsg_hdr *)
+	    &kvp_globals.rcv_buf[sizeof(struct hv_vmbus_pipe_hdr)];
+
+	if (error)
+		error = HV_KVP_E_FAIL;
+
+	hv_icmsg_hdrp->status = error;
+	hv_icmsg_hdrp->icflags = HV_ICMSGHDRFLAG_TRANSACTION | HV_ICMSGHDRFLAG_RESPONSE;
+	
+	error = hv_vmbus_channel_send_packet(kvp_globals.channelp,
+			kvp_globals.rcv_buf,
+			kvp_globals.host_msg_len, kvp_globals.host_msg_id,
+			HV_VMBUS_PACKET_TYPE_DATA_IN_BAND, 0);
+
+	if (error)
+		hv_kvp_log_info("%s: hv_kvp_respond_host: sendpacket error:%d\n",
+			__func__, error);
+}
+
+
+/*
+ * This is the main kvp kernel process that interacts with both user daemon
+ * and the host
+ */
+static void
+hv_kvp_send_msg_to_daemon(void)
+{
+	/* Prepare kvp_msg to be sent to user */
+	hv_kvp_convert_hostmsg_to_usermsg();
+
+	/* Send the msg to user via function deamon_read - setting sema */
+	sema_post(&kvp_globals.dev_sema);
+}
+
+
+/*
+ * Function to read the kvp request buffer from host
+ * and interact with daemon
+ */
+static void
+hv_kvp_process_request(void *context)
+{
+	uint8_t *kvp_buf;
+	hv_vmbus_channel *channel = context;
+	uint32_t recvlen = 0;
+	uint64_t requestid;
+	struct hv_vmbus_icmsg_hdr *icmsghdrp;
+	int ret = 0;
+	uint64_t pending_cnt = 1;
+	
+	hv_kvp_log_info("%s: entering hv_kvp_process_request\n", __func__);
+	kvp_buf = receive_buffer[HV_KVP];
+	ret = hv_vmbus_channel_recv_packet(channel, kvp_buf, 2 * PAGE_SIZE,
+		&recvlen, &requestid);
+
+	/*
+	 * We start counting only after the daemon registers
+	 * and therefore there could be requests pending in 
+	 * the VMBus that are not reflected in pending_cnt.
+	 * Therefore we continue reading as long as either of
+	 * the below conditions is true.
+	 */
+
+	while ((pending_cnt>0) || ((ret == 0) && (recvlen > 0))) {
+
+		if ((ret == 0) && (recvlen>0)) {
+			
+			icmsghdrp = (struct hv_vmbus_icmsg_hdr *)
+					&kvp_buf[sizeof(struct hv_vmbus_pipe_hdr)];
+	
+			hv_kvp_transaction_init(recvlen, channel, requestid, kvp_buf);
+			if (icmsghdrp->icmsgtype == HV_ICMSGTYPE_NEGOTIATE) {
+				hv_kvp_negotiate_version(icmsghdrp, NULL, kvp_buf);
+				hv_kvp_respond_host(ret);
+					
+				/*
+				 * It is ok to not acquire the mutex before setting 
+				 * req_in_progress here because negotiation is the
+				 * first thing that happens and hence there is no
+				 * chance of a race condition.
+				 */
+				
+				kvp_globals.req_in_progress = false;
+				hv_kvp_log_info("%s :version negotiated\n", __func__);
+
+			} else {
+				if (!kvp_globals.daemon_busy) {
+
+					hv_kvp_log_info("%s: issuing qury to daemon\n", __func__);
+					mtx_lock(&kvp_globals.pending_mutex);
+					kvp_globals.req_timed_out = false;
+					kvp_globals.daemon_busy = true;
+					mtx_unlock(&kvp_globals.pending_mutex);
+
+					hv_kvp_send_msg_to_daemon();
+					hv_kvp_log_info("%s: waiting for daemon\n", __func__);
+				}
+				
+				/* Wait 5 seconds for daemon to respond back */
+				tsleep(&kvp_globals, 0, "kvpworkitem", 5 * hz);
+				hv_kvp_log_info("%s: came out of wait\n", __func__);
+			}
+		}
+
+		mtx_lock(&kvp_globals.pending_mutex);
+		
+		/* Notice that once req_timed_out is set to true
+		 * it will remain true until the next request is
+		 * sent to the daemon. The response from daemon
+		 * is forwarded to host only when this flag is 
+		 * false. 
+		 */
+		kvp_globals.req_timed_out = true;
+
+		/*
+		 * Cancel request if so need be.
+		 */
+		if (hv_kvp_req_in_progress()) {
+			hv_kvp_log_info("%s: request was still active after wait so failing\n", __func__);
+			hv_kvp_respond_host(HV_KVP_E_FAIL);
+			kvp_globals.req_in_progress = false;	
+		}
+	
+		/*
+		* Decrement pending request count and
+		*/
+		if (kvp_globals.pending_reqs>0) {
+			kvp_globals.pending_reqs = kvp_globals.pending_reqs - 1;
+		}
+		pending_cnt = kvp_globals.pending_reqs;
+		
+		mtx_unlock(&kvp_globals.pending_mutex);
+
+		/*
+		 * Try reading next buffer
+		 */
+		recvlen = 0;
+		ret = hv_vmbus_channel_recv_packet(channel, kvp_buf, 2 * PAGE_SIZE,
+			&recvlen, &requestid);
+		hv_kvp_log_info("%s: read: context %p, pending_cnt %lu ret =%d, recvlen=%d\n",
+			__func__, context, pending_cnt, ret, recvlen);
+	} 
+}
+
+
+/*
+ * Callback routine that gets called whenever there is a message from host
+ */
+void
+hv_kvp_callback(void *context)
+{
+	uint64_t pending_cnt = 0;
+
+	if (kvp_globals.register_done == false) {
+		
+		kvp_globals.channelp = context;
+	} else {
+		
+		mtx_lock(&kvp_globals.pending_mutex);
+		kvp_globals.pending_reqs = kvp_globals.pending_reqs + 1;
+		pending_cnt = kvp_globals.pending_reqs;
+		mtx_unlock(&kvp_globals.pending_mutex);
+		if (pending_cnt == 1) {
+			hv_kvp_log_info("%s: Queuing work item\n", __func__);
+			hv_queue_work_item(
+					service_table[HV_KVP].work_queue,
+					hv_kvp_process_request,
+					context
+					);
+		}
+	}	
+}
+
+
+/*
+ * This function is called by the hv_kvp_init -
+ * creates character device hv_kvp_dev 
+ * allocates memory to hv_kvp_dev_buf
+ *
+ */
+static int
+hv_kvp_dev_init(void)
+{
+	int error = 0;
+
+	/* initialize semaphore */
+	sema_init(&kvp_globals.dev_sema, 0, "hv_kvp device semaphore");
+	/* create character device */
+	error = make_dev_p(MAKEDEV_CHECKNAME | MAKEDEV_WAITOK,
+			&hv_kvp_dev,
+			&hv_kvp_cdevsw,
+			0,
+			UID_ROOT,
+			GID_WHEEL,
+			0640,
+			"hv_kvp_dev");
+					   
+	if (error != 0)
+		return (error);
+
+	hv_kvp_dev_buf = malloc(sizeof(*hv_kvp_dev_buf), M_HV_KVP_DEV_BUF, M_WAITOK |
+				M_ZERO);
+
+	if (!hv_kvp_dev_buf) {
+		destroy_dev(hv_kvp_dev);
+		error = ENOMEM;
+		hv_kvp_log_error("%s: ENOMEM\n", __func__);
+	}
+
+	return (error);
+}
+
+
+/*
+ * This function is called by the hv_kvp_deinit -
+ * destroy character device
+ */
+static void
+hv_kvp_dev_destroy(void)
+{
+
+        if (daemon_task != NULL) {
+		PROC_LOCK(daemon_task);
+        	kern_psignal(daemon_task, SIGKILL);
+		PROC_UNLOCK(daemon_task);
+	}
+	
+	destroy_dev(hv_kvp_dev);
+	free(hv_kvp_dev_buf, M_HV_KVP_DEV_BUF);
+	return;
+}
+
+
+static int
+hv_kvp_dev_open(struct cdev *dev, int oflags, int devtype,
+				struct thread *td)
+{
+	
+	hv_kvp_log_info("%s: Opened device \"hv_kvp_device\" successfully.\n", __func__);
+	if (kvp_globals.dev_accessed)
+		return (-EBUSY);
+	
+	daemon_task = curproc;
+	kvp_globals.dev_accessed = true;
+	return (0);
+}
+
+
+static int
+hv_kvp_dev_close(struct cdev *dev __unused, int fflag __unused, int devtype __unused,
+				 struct thread *td __unused)
+{
+
+	hv_kvp_log_info("%s: Closing device \"hv_kvp_device\".\n", __func__);
+	kvp_globals.dev_accessed = false;
+	kvp_globals.register_done = false;
+	return (0);
+}
+
+
+/*
+ * hv_kvp_daemon read invokes this function
+ * acts as a send to daemon
+ */
+static int
+hv_kvp_dev_daemon_read(struct cdev *dev __unused, struct uio *uio, int ioflag __unused)
+{
+	size_t amt;
+	int error = 0;
+
+	/* Check hv_kvp daemon registration status*/
+	if (!kvp_globals.register_done)
+		return (KVP_ERROR);
+
+	sema_wait(&kvp_globals.dev_sema);
+
+	memcpy(hv_kvp_dev_buf, &kvp_globals.daemon_kvp_msg, sizeof(struct hv_kvp_msg));
+
+	amt = MIN(uio->uio_resid, uio->uio_offset >= BUFFERSIZE + 1 ? 0 :
+		BUFFERSIZE + 1 - uio->uio_offset);
+
+	if ((error = uiomove(hv_kvp_dev_buf, amt, uio)) != 0)
+		hv_kvp_log_info("%s: hv_kvp uiomove read failed!\n", __func__);
+
+	return (error);
+}
+
+
+/*
+ * hv_kvp_daemon write invokes this function
+ * acts as a recieve from daemon
+ */
+static int
+hv_kvp_dev_daemon_write(struct cdev *dev __unused, struct uio *uio, int ioflag __unused)
+{
+	size_t amt;
+	int error = 0;
+
+	uio->uio_offset = 0;
+
+	amt = MIN(uio->uio_resid, BUFFERSIZE);
+	error = uiomove(hv_kvp_dev_buf, amt, uio);
+
+	if (error != 0)
+		return (error);
+
+	memcpy(&kvp_globals.daemon_kvp_msg, hv_kvp_dev_buf, sizeof(struct hv_kvp_msg));
+
+	if (kvp_globals.register_done == false) {
+		if (kvp_globals.daemon_kvp_msg.kvp_hdr.operation == HV_KVP_OP_REGISTER) {
+
+			kvp_globals.register_done = true;
+			if (kvp_globals.channelp) {
+			
+				hv_kvp_callback(kvp_globals.channelp);
+			}
+		}
+		else {
+			hv_kvp_log_info("%s, KVP Registration Failed\n", __func__);
+			return (KVP_ERROR);
+		}
+	} else {
+
+		mtx_lock(&kvp_globals.pending_mutex);
+
+		if(!kvp_globals.req_timed_out) {
+
+			hv_kvp_convert_usermsg_to_hostmsg();
+			hv_kvp_respond_host(KVP_SUCCESS);
+			wakeup(&kvp_globals);
+			kvp_globals.req_in_progress = false;
+		}
+
+		kvp_globals.daemon_busy = false;
+		mtx_unlock(&kvp_globals.pending_mutex);
+	}
+
+	return (error);
+}
+
+
+/* 
+ * hv_kvp initialization function 
+ * called from hv_util service.
+ *
+ */
+int
+hv_kvp_init(hv_vmbus_service *srv)
+{
+	int error = 0;
+	hv_work_queue *work_queue = NULL;
+	
+	memset(&kvp_globals, 0, sizeof(kvp_globals));
+
+	work_queue = hv_work_queue_create("KVP Service");
+	if (work_queue == NULL) {
+		hv_kvp_log_info("%s: Work queue alloc failed\n", __func__);
+		error = ENOMEM;
+		hv_kvp_log_error("%s: ENOMEM\n", __func__);
+		goto Finish;
+	}
+	srv->work_queue = work_queue;
+
+	error = hv_kvp_dev_init();
+	mtx_init(&kvp_globals.pending_mutex, "hv-kvp pending mutex",
+		       	NULL, MTX_DEF);	
+	kvp_globals.pending_reqs = 0;
+
+
+Finish:
+	return (error);
+}
+
+
+void
+hv_kvp_deinit(void)
+{
+	hv_kvp_dev_destroy();
+	mtx_destroy(&kvp_globals.pending_mutex);
+
+	return;
+}

Property changes on: sys/dev/hyperv/utilities/hv_kvp.c
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+text/plain
\ No newline at end of property
Added: svn:keywords
## -0,0 +1 ##
+FreeBSD=%H
\ No newline at end of property
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: sys/dev/hyperv/utilities/hv_kvp.h
===================================================================
--- sys/dev/hyperv/utilities/hv_kvp.h	(revision 267674)
+++ sys/dev/hyperv/utilities/hv_kvp.h	(working copy)
@@ -1,7 +1,5 @@
 /*-
- * Copyright (c) 2009-2012 Microsoft Corp.
- * Copyright (c) 2012 NetApp Inc.
- * Copyright (c) 2012 Citrix Inc.
+ * Copyright (c) 2014 Microsoft Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -30,7 +28,7 @@
 #define _KVP_H
 
 /*
- * An implementation of HyperV key value pair (KVP) functionality for FreeBSD 
+ * An implementation of HyperV key value pair (KVP) functionality for FreeBSD
  *
  */
 
@@ -53,7 +51,7 @@
 /*
  * bytes, including any null terminators
  */
-#define HV_KVP_EXCHANGE_MAX_VALUE_SIZE          (2048)
+#define HV_KVP_EXCHANGE_MAX_VALUE_SIZE    (2048)
 
 
 /*
@@ -60,8 +58,8 @@
  * Maximum key size - the registry limit for the length of an entry name
  * is 256 characters, including the null terminator
  */
+#define HV_KVP_EXCHANGE_MAX_KEY_SIZE    (512)
 
-#define HV_KVP_EXCHANGE_MAX_KEY_SIZE            (512)
 
 /*
  * In FreeBSD, we implement the KVP functionality in two components:
@@ -111,30 +109,20 @@
  * (not supported), a NULL key string is returned.
  */
 
-
+ 
 /*
  * Registry value types.
  */
+#define HV_REG_SZ     1
+#define HV_REG_U32    4
+#define HV_REG_U64    8
 
-#define HV_REG_SZ  1
-#define HV_REG_U32 4
-#define HV_REG_U64 8
 
-
 /*
- * Daemon code not supporting IP injection (legacy daemon).
- */
-
-#define HV_KVP_OP_REGISTER	4
-
-/*
  * Daemon code supporting IP injection.
- * The KVP opcode field is used to communicate the
- * registration information; so define a namespace that
- * will be distinct from the host defined KVP opcode.
  */
+#define HV_KVP_OP_REGISTER    4
 
-#define KVP_OP_REGISTER1 100
 
 enum hv_kvp_exchg_op {
 	HV_KVP_OP_GET = 0,
@@ -155,41 +143,41 @@
 	HV_KVP_POOL_COUNT /* Number of pools, must be last. */
 };
 
+
 /*
  * Some Hyper-V status codes.
  */
-#define HV_KVP_S_OK				0x00000000
-#define HV_KVP_E_FAIL			0x80004005
-#define HV_KVP_S_CONT			0x80070103
-#define HV_ERROR_NOT_SUPPORTED		0x80070032
-#define HV_ERROR_MACHINE_LOCKED		0x800704F7
-#define HV_ERROR_DEVICE_NOT_CONNECTED	0x8007048F
-#define HV_INVALIDARG			0x80070057
-#define HV_KVP_GUID_NOTFOUND		0x80041002
+#define HV_KVP_S_OK                      0x00000000
+#define HV_KVP_E_FAIL                    0x80004005
+#define HV_KVP_S_CONT                    0x80070103
+#define HV_ERROR_NOT_SUPPORTED           0x80070032
+#define HV_ERROR_MACHINE_LOCKED          0x800704F7
+#define HV_ERROR_DEVICE_NOT_CONNECTED    0x8007048F
+#define HV_INVALIDARG                    0x80070057
+#define HV_KVP_GUID_NOTFOUND             0x80041002
 
-#define ADDR_FAMILY_NONE	0x00
-#define ADDR_FAMILY_IPV4	0x01
-#define ADDR_FAMILY_IPV6	0x02
+#define ADDR_FAMILY_NONE                 0x00
+#define ADDR_FAMILY_IPV4                 0x01
+#define ADDR_FAMILY_IPV6                 0x02
 
-#define MAX_ADAPTER_ID_SIZE	128
-#define MAX_IP_ADDR_SIZE	1024
-#define MAX_GATEWAY_SIZE	512
+#define MAX_ADAPTER_ID_SIZE              128
+#define MAX_IP_ADDR_SIZE                 1024
+#define MAX_GATEWAY_SIZE                 512
 
 
 struct hv_kvp_ipaddr_value {
-	uint16_t	adapter_id[MAX_ADAPTER_ID_SIZE];
-	uint8_t	addr_family;
-	uint8_t	dhcp_enabled;
-	uint16_t	ip_addr[MAX_IP_ADDR_SIZE];
-	uint16_t	sub_net[MAX_IP_ADDR_SIZE];
-	uint16_t	gate_way[MAX_GATEWAY_SIZE];
-	uint16_t	dns_addr[MAX_IP_ADDR_SIZE];
-} __attribute__((packed));
+	uint16_t adapter_id[MAX_ADAPTER_ID_SIZE];
+	uint8_t  addr_family;
+	uint8_t  dhcp_enabled;
+	uint16_t ip_addr[MAX_IP_ADDR_SIZE];
+	uint16_t sub_net[MAX_IP_ADDR_SIZE];
+	uint16_t gate_way[MAX_GATEWAY_SIZE];
+	uint16_t dns_addr[MAX_IP_ADDR_SIZE];
+}__attribute__((packed));
 
-
 struct hv_kvp_hdr {
-	uint8_t operation;
-	uint8_t pool;
+	uint8_t  operation;
+	uint8_t  pool;
 	uint16_t pad;
 } __attribute__((packed));
 
@@ -197,9 +185,9 @@
 	uint32_t value_type;
 	uint32_t key_size;
 	uint32_t value_size;
-	uint8_t key[HV_KVP_EXCHANGE_MAX_KEY_SIZE];
+	uint8_t  key[HV_KVP_EXCHANGE_MAX_KEY_SIZE];
 	union {
-		uint8_t value[HV_KVP_EXCHANGE_MAX_VALUE_SIZE];
+		uint8_t  value[HV_KVP_EXCHANGE_MAX_VALUE_SIZE];
 		uint32_t value_u32;
 		uint64_t value_u64;
 	} msg_value;
@@ -229,16 +217,16 @@
 
 struct hv_kvp_msg {
 	union {
-		struct hv_kvp_hdr	kvp_hdr;
+		struct hv_kvp_hdr kvp_hdr;
 		int error;
 	} hdr;
 	union {
-		struct hv_kvp_msg_get	kvp_get;
-		struct hv_kvp_msg_set	kvp_set;
+		struct hv_kvp_msg_get		kvp_get;
+		struct hv_kvp_msg_set		kvp_set;
 		struct hv_kvp_msg_delete	kvp_delete;
 		struct hv_kvp_msg_enumerate	kvp_enum_data;
-		struct hv_kvp_ipaddr_value  kvp_ip_val;
-		struct hv_kvp_register	kvp_register;
+		struct hv_kvp_ipaddr_value	kvp_ip_val;
+		struct hv_kvp_register		kvp_register;
 	} body;
 } __attribute__((packed));
 
@@ -248,38 +236,17 @@
 	struct hv_kvp_ipaddr_value      kvp_ip_val;
 } __attribute__((packed));
 
-#define BSD_SOC_PATH "/etc/hyperv/socket" 
 
-#define HV_SHUT_DOWN		0
-#define HV_TIME_SYNCH	 	1
-#define HV_HEART_BEAT	 	2
-#define HV_KVP		 	3
-#define HV_MAX_UTIL_SERVICES 	4
+#define HV_SHUT_DOWN                0
+#define HV_TIME_SYNCH               1
+#define HV_HEART_BEAT               2
+#define HV_KVP                      3
+#define HV_MAX_UTIL_SERVICES        4
 
-#define HV_WLTIMEDELTA			116444736000000000L /* in 100ns unit */
-#define HV_ICTIMESYNCFLAG_PROBE		0
-#define HV_ICTIMESYNCFLAG_SYNC		1
-#define HV_ICTIMESYNCFLAG_SAMPLE	2
-#define HV_NANO_SEC_PER_SEC 		1000000000
+#define HV_WLTIMEDELTA              116444736000000000L     /* in 100ns unit */
+#define HV_ICTIMESYNCFLAG_PROBE     0
+#define HV_ICTIMESYNCFLAG_SYNC      1
+#define HV_ICTIMESYNCFLAG_SAMPLE    2
+#define HV_NANO_SEC_PER_SEC         1000000000
 
-typedef struct hv_vmbus_service {
-	hv_guid		guid;		/* Hyper-V GUID */
-       char*			name;		/* name of service */
-       boolean_t		enabled;	/* service enabled */
-       hv_work_queue*	work_queue;	/* background work queue */
-	
-	//
-	// function to initialize service
-	//
-       int (*init)(struct hv_vmbus_service *);
-	
-	//
-	// function to process Hyper-V messages 
-	//
-       void (*callback)(void *);
-} hv_vmbus_service;
-
-extern uint8_t* receive_buffer[];
-extern hv_vmbus_service service_table[];
-
 #endif /* _KVP_H */
Index: sys/dev/hyperv/utilities/hv_util.c
===================================================================
--- sys/dev/hyperv/utilities/hv_util.c	(revision 267674)
+++ sys/dev/hyperv/utilities/hv_util.c	(working copy)
@@ -1,7 +1,5 @@
 /*-
- * Copyright (c) 2009-2012 Microsoft Corp.
- * Copyright (c) 2012 NetApp Inc.
- * Copyright (c) 2012 Citrix Inc.
+ * Copyright (c) 2014 Microsoft Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,7 +24,7 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/**
+/*
  * A common driver for all hyper-V util services.
  */
 
@@ -53,7 +51,7 @@
 
 static int hv_timesync_init(hv_vmbus_service *serv);
 
-/**
+/*
  * Note: GUID codes below are predefined by the host hypervisor
  * (Hyper-V and Azure)interface and required for correct operation.
  */
@@ -80,8 +78,17 @@
 			0xab, 0x55, 0x38, 0x2f, 0x3b, 0xd5, 0x42, 0x2d},
 	  .name = "Hyper-V Heartbeat Service\n",
 	  .enabled = TRUE,
-          .callback = hv_heartbeat_cb,
+  	  .callback = hv_heartbeat_cb,
 	},
+
+        /* KVP (Key Value Pair) Service */
+        { .guid.data = {0xe7, 0xf4, 0xa0, 0xa9, 0x45, 0x5a, 0x96, 0x4d,
+			0xb8, 0x27, 0x8a, 0x84, 0x1e, 0x8c, 0x3,  0xe6},
+	  .name = "Hyper-V KVP Service\n",
+	  .enabled = TRUE,
+	  .init = hv_kvp_init,
+	  .callback = hv_kvp_callback,
+	},
 };
 
 /*
@@ -90,6 +97,8 @@
  */
 uint8_t *receive_buffer[HV_MAX_UTIL_SERVICES];
 
+static boolean_t destroyed_kvp = FALSE;
+
 struct hv_ictimesync_data {
 	uint64_t    parenttime;
 	uint64_t    childtime;
@@ -143,7 +152,7 @@
 static void
 hv_set_host_time(void *context)
 {
- 	time_sync_data *time_msg = context;	
+ 	time_sync_data* time_msg = (time_sync_data*) context;	
 	uint64_t hosttime = time_msg->data;
 	struct timespec guest_ts, host_ts;
 	uint64_t host_tns;
@@ -253,12 +262,12 @@
 static void
 hv_shutdown_cb(void *context)
 {
-	uint8_t*			buf;
+	uint8_t*		buf;
 	hv_vmbus_channel*		channel = context;
-	uint8_t				execute_shutdown = 0;
+	uint8_t			execute_shutdown = 0;
 	hv_vmbus_icmsg_hdr*		icmsghdrp;
-	uint32_t			recv_len;
-	uint64_t			request_id;
+	uint32_t		recv_len;
+	uint64_t		request_id;
 	int				ret;
 	hv_vmbus_shutdown_msg_data*	shutdown_msg;
 
@@ -421,6 +430,11 @@
 	struct hv_vmbus_service*	service;
 	size_t				receive_buffer_offset;
 
+	if (!destroyed_kvp) {
+		hv_kvp_deinit();
+		destroyed_kvp = TRUE;
+	}
+
 	hv_dev = vmbus_get_devctx(dev);
 
 	hv_vmbus_channel_close(hv_dev->channel);
@@ -432,21 +446,22 @@
 
 	free(receive_buffer[receive_buffer_offset], M_DEVBUF);
 	receive_buffer[receive_buffer_offset] = NULL;
-
 	return (0);
 }
 
-static void hv_util_init(void)
+static void
+hv_util_init(void)
 {
 }
 
-static int hv_util_modevent(module_t mod, int event, void *arg)
+static int
+hv_util_modevent(module_t mod, int event, void *arg)
 {
 	switch (event) {
         case MOD_LOAD:
                 break;
         case MOD_UNLOAD:
-                break;
+		break;
 	default:
 		break;
         }
Index: sys/dev/hyperv/utilities/unicode.h
===================================================================
--- sys/dev/hyperv/utilities/unicode.h	(revision 0)
+++ sys/dev/hyperv/utilities/unicode.h	(working copy)
@@ -0,0 +1,199 @@
+/* $NetBSD: unicode.h,v 1.1.1.1 2007/03/06 00:10:39 dillo Exp $ */
+
+/*-
+ * Copyright (c) 2007 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Dieter Baron.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/types.h>
+
+#define UNICODE_DECOMPOSE		0x01
+#define UNICODE_PRECOMPOSE		0x02
+#define UNICODE_UTF8_LATIN1_FALLBACK	0x03
+
+size_t utf8_to_utf16(uint16_t *, size_t, const char *, size_t, int, int *);
+size_t utf16_to_utf8(char *, size_t, const uint16_t *, size_t, int, int *);
+
+size_t
+utf8_to_utf16(uint16_t *dst, size_t dst_len,
+	      const char *src, size_t src_len,
+	      int flags, int *errp)
+{
+    const unsigned char *s;
+    size_t spos, dpos;
+    int error;
+    uint16_t c;
+
+#define IS_CONT(c)	(((c)&0xc0) == 0x80)
+
+    error = 0;
+    s = (const unsigned char *)src;
+    spos = dpos = 0;
+    while (spos<src_len) {
+	if (s[spos] < 0x80)
+	    c = s[spos++];
+	else if ((flags & UNICODE_UTF8_LATIN1_FALLBACK)
+		 && (spos >= src_len || !IS_CONT(s[spos+1]))
+		 && s[spos]>=0xa0) {
+	    /* not valid UTF-8, assume ISO 8859-1 */
+	    c = s[spos++];
+	}
+	else if (s[spos] < 0xc0 || s[spos] >= 0xf5) {
+	    /* continuation byte without lead byte
+	       or lead byte for codepoint above 0x10ffff */
+	    error++;
+	    spos++;
+	    continue;
+	}
+	else if (s[spos] < 0xe0) {
+	    if (spos >= src_len || !IS_CONT(s[spos+1])) {
+		spos++;
+		error++;
+		continue;
+	    }
+	    c = ((s[spos] & 0x3f) << 6) | (s[spos+1] & 0x3f);
+	    spos += 2;
+	    if (c < 0x80) {
+		/* overlong encoding */
+		error++;
+		continue;
+	    }
+	}
+	else if (s[spos] < 0xf0) {
+	    if (spos >= src_len-2
+		|| !IS_CONT(s[spos+1]) || !IS_CONT(s[spos+2])) {
+		spos++;
+		error++;
+		continue;
+	    }
+	    c = ((s[spos] & 0x0f) << 12) | ((s[spos+1] & 0x3f) << 6)
+		| (s[spos+2] & 0x3f);
+	    spos += 3;
+	    if (c < 0x800 || (c & 0xdf00) == 0xd800 ) {
+		/* overlong encoding or encoded surrogate */
+		error++;
+		continue;
+	    }
+	}
+	else {
+	    uint32_t cc;
+	    /* UTF-16 surrogate pair */
+
+	    if (spos >= src_len-3 || !IS_CONT(s[spos+1])
+		|| !IS_CONT(s[spos+2]) || !IS_CONT(s[spos+3])) {
+		spos++;
+		error++;
+		
+		continue;
+	    }
+	    cc = ((s[spos] & 0x03) << 18) | ((s[spos+1] & 0x3f) << 12)
+		 | ((s[spos+2] & 0x3f) << 6) | (s[spos+3] & 0x3f);
+	    spos += 4;
+	    if (cc < 0x10000) {
+		/* overlong encoding */
+		error++;
+		continue;
+	    }
+	    if (dst && dpos < dst_len)
+		dst[dpos] = (0xd800 | ((cc-0x10000)>>10));
+	    dpos++;
+	    c = 0xdc00 | ((cc-0x10000) & 0x3ffff);
+	}
+
+	if (dst && dpos < dst_len)
+	    dst[dpos] = c;
+	dpos++;
+    }
+    
+    if (errp)
+	*errp = error;
+
+    return dpos;
+
+#undef IS_CONT
+}
+
+
+size_t
+utf16_to_utf8(char *dst, size_t dst_len,
+	      const uint16_t *src, size_t src_len,
+	      int flags, int *errp)
+{
+    uint16_t spos, dpos;
+    int error;
+
+#define CHECK_LENGTH(l)	(dpos > dst_len-(l) ? dst=NULL : NULL)
+#define ADD_BYTE(b)	(dst ? dst[dpos] = (b) : 0, dpos++)
+
+    error = 0;
+    dpos = 0;
+    for (spos=0; spos<src_len; spos++) {
+	if (src[spos] < 0x80) {
+	    CHECK_LENGTH(1);
+	    ADD_BYTE(src[spos]);
+	}
+	else if (src[spos] < 0x800) {
+	    CHECK_LENGTH(2);
+	    ADD_BYTE(0xc0 | (src[spos]>>6));
+	    ADD_BYTE(0x80 | (src[spos] & 0x3f));
+	}
+	else if ((src[spos] & 0xdc00) == 0xd800) {
+	    uint32_t c;
+	    /* first surrogate */
+	    if (spos == src_len - 1 || (src[spos] & 0xdc00) != 0xdc00) {
+		/* no second surrogate present */
+		error++;
+		continue;
+	    }
+	    spos++;
+	    CHECK_LENGTH(4);
+	    c = (((src[spos]&0x3ff) << 10) | (src[spos+1]&0x3ff)) + 0x10000;
+	    ADD_BYTE(0xf0 | (c>>18));
+	    ADD_BYTE(0x80 | ((c>>12) & 0x3f));
+	    ADD_BYTE(0x80 | ((c>>6) & 0x3f));
+	    ADD_BYTE(0x80 | (c & 0x3f));
+	}
+	else if ((src[spos] & 0xdc00) == 0xdc00) {
+	    /* second surrogate without preceding first surrogate */
+	    error++;
+	}
+	else {
+	    CHECK_LENGTH(3);
+	    ADD_BYTE(0xe0 | src[spos]>>12);
+	    ADD_BYTE(0x80 | ((src[spos]>>6) & 0x3f));
+	    ADD_BYTE(0x80 | (src[spos] & 0x3f));
+	}
+    }
+
+    if (errp)
+	*errp = error;
+
+    return dpos;
+
+#undef ADD_BYTE
+#undef CHECK_LENGTH
+}

Property changes on: sys/dev/hyperv/utilities/unicode.h
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+text/plain
\ No newline at end of property
Added: svn:keywords
## -0,0 +1 ##
+FreeBSD=%H
\ No newline at end of property
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: sys/modules/hyperv/utilities/Makefile
===================================================================
--- sys/modules/hyperv/utilities/Makefile	(revision 267674)
+++ sys/modules/hyperv/utilities/Makefile	(working copy)
@@ -3,7 +3,7 @@
 .PATH:	${.CURDIR}/../../../dev/hyperv/utilities
 
 KMOD=	hv_utils
-SRCS=	hv_util.c
+SRCS=	hv_util.c hv_kvp.c
 SRCS+=	bus_if.h device_if.h
 
 CFLAGS+= -I${.CURDIR}/../../../dev/hyperv/include \
Index: usr.sbin/Makefile
===================================================================
--- usr.sbin/Makefile	(revision 267674)
+++ usr.sbin/Makefile	(working copy)
@@ -33,6 +33,7 @@
 	getfmac \
 	getpmac \
 	gstat \
+	hyperv \
 	i2c \
 	ifmcstat \
 	inetd \
Index: usr.sbin/hyperv/Makefile
===================================================================
--- usr.sbin/hyperv/Makefile	(revision 0)
+++ usr.sbin/hyperv/Makefile	(working copy)
@@ -0,0 +1,7 @@
+# $FreeBSD hyperv-ic Makefile  $
+
+.include <bsd.own.mk>
+
+SUBDIR = tools 
+
+.include <bsd.subdir.mk>

Property changes on: usr.sbin/hyperv/Makefile
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+text/plain
\ No newline at end of property
Added: svn:keywords
## -0,0 +1 ##
+FreeBSD=%H
\ No newline at end of property
Index: usr.sbin/hyperv/tools/Makefile
===================================================================
--- usr.sbin/hyperv/tools/Makefile	(revision 0)
+++ usr.sbin/hyperv/tools/Makefile	(working copy)
@@ -0,0 +1,23 @@
+# $FreeBSD hyperv-ic Makefile  $
+
+.include <bsd.own.mk>
+
+HV_KVP_DAEMON_DISTDIR?= ${.CURDIR}/../../../contrib/hyperv/tools
+.PATH: ${HV_KVP_DAEMON_DISTDIR} 
+BINDIR =  /usr/sbin
+
+PROG= 	hv_kvp_daemon
+MAN= 	hv_kvp_daemon.8	
+
+${PROG}: ${PROG}.c
+	${CC} -o ${PROG}  ${HV_KVP_DAEMON_DISTDIR}/${PROG}.c 
+
+beforeinstall:
+	chmod 755 ${HV_KVP_DAEMON_DISTDIR}/kvp-install
+	${SH} ${HV_KVP_DAEMON_DISTDIR}/kvp-install PRE-INSTALL	
+	
+afterinstall:
+	${SH} ${HV_KVP_DAEMON_DISTDIR}/kvp-install POST-INSTALL	
+	${INSTALL} ${COPY} ${HV_KVP_DAEMON_DISTDIR}/scripts/* /usr/local/hyperv/scripts/
+
+.include <bsd.prog.mk>

Property changes on: usr.sbin/hyperv/tools/Makefile
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+text/plain
\ No newline at end of property
Added: svn:keywords
## -0,0 +1 ##
+FreeBSD=%H
\ No newline at end of property
